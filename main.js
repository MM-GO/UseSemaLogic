/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  DebugLevel: () => DebugLevel,
  Default_profile: () => Default_profile,
  SemaLogicPluginComm: () => SemaLogicPluginComm2,
  default: () => SemaLogicPlugin,
  mygSID: () => mygSID
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/view.ts
var import_obsidian3 = require("obsidian");

// src/const.ts
var API_Defaults = {
  http: "http://",
  https: "https://",
  Base_URL: "service.semalogic.ddns.net",
  Port: "443",
  rules_parse: "/rules/parse",
  reset: "/reset",
  Version: "/APIVersion",
  PostDialect: "/dialect/define",
  RemoveDialect: "/dialect/remove",
  GetAPI: "/APIVersion",
  SID: "12345678",
  ShowContext: true,
  useUserPasswortforHTTP: true,
  HttpUser: "User",
  HttpPassword: "Password",
  viewheader: "SVG",
  AspUrl: "ASP-Service-URL.com/",
  AspEndpoint: "/plans/count",
  useUserPasswortforHTTPSL: true,
  HttpUserSL: "User",
  HttpPasswordSL: "Password"
};
var Value_Defaults = {
  updateInterval: 500
};
var semaLogicCommand = {
  command_start: "SemaLogic(",
  command_end: ")",
  showHelp: "show help",
  showVersion: "show version",
  getDialectwTemplate: "template",
  useDialect: "use ???dialectName???",
  define: "define",
  showParse: "show as",
  showFilter: "for",
  transfer: "transfer",
  transferEndpoint: "to endpoint",
  transferParam: "with param"
};
var semaLogicHelp = [
  [semaLogicCommand.command_start + "???" + semaLogicCommand.command_end, "You can define what SemaLogic should do for you by replacing ??? with one of the following SemaLogic commands:"],
  [semaLogicCommand.command_start + semaLogicCommand.showHelp + semaLogicCommand.command_end, "Show this help information"],
  [semaLogicCommand.command_start + semaLogicCommand.showVersion + semaLogicCommand.command_end, "Show the version of the SemaLogic-Service"],
  [semaLogicCommand.command_start + semaLogicCommand.define + semaLogicCommand.command_end, "After this inlinecommand and a space line comes e.g. a table that should be interpreted by SemaLogic (table, NTable, ZTable) with optional headerinterpretation- Expected format:\n(|Symbol||Level(n+1)|\n|---|---|\n|Level(1)|Level(n)|Value|)"],
  [`${semaLogicCommand.command_start + semaLogicCommand.showParse} %1 ${semaLogicCommand.showFilter} %2 ${semaLogicCommand.command_end}`, "show as - shows an output directly to the reading view ( with %1 you have to set the output type: 1|1 {picture, syemalogic, asp} and with %2 you could filter for an symbol by symbolname)"],
  [`${semaLogicCommand.command_start + semaLogicCommand.transfer} %1 ${semaLogicCommand.transferEndpoint} %2 ${semaLogicCommand.transferParam} %3 ${semaLogicCommand.command_end}`, "transfer - shows an (currently only) asp output directly to the asp.view from SemaLogicView ( with %1 you have to set the output type: 1|1 {asp} and with %2 you could set the endpoint and wuth %3 you could set queryparameter)"]
];
var Rstypes_Semalogic = 0;
var Rstypes_Picture = 3;
var Rstypes_ASP = 6;
var Rstypes_SemanticTree = 8;
var Rstypes_KnowledgeGraph = 9;
var RulesettypesCommands = [
  ["SemaLogic", "SemaLogic"],
  ["technical", "SemaLogic"],
  ["semalogic", "SemaLogic"],
  ["Picture (SVG)", "SVG"],
  ["picture", "SVG"],
  ["SVG", "SVG"],
  ["ASP", "ASP.json"],
  ["asp", "ASP.json"],
  ["SemanticTree", "SemanticTree"],
  ["KnwoledgeGraph", "KnowledgeGraph"]
];
var DebugLevelNames = [
  "DebugLevel_Off",
  "DebugLevel_Error",
  "DebugLevel_Current_Dev",
  "DebugLevel_Important",
  "DebugLevel_Informative",
  "DebugLevel_Chatty",
  "DebugLevel_All"
];
var DebugLevMap = {
  "DebugLevel_Off": 0,
  "DebugLevel_Error": 1,
  "DebugLevel_Current_Dev": 2,
  "DebugLevel_Important": 3,
  "DebugLevel_Informative": 4,
  "DebugLevel_Chatty": 5,
  "DebugLevel_All": 6
};
var slTexts = {
  "HeaderSL": "SemaLogic.View",
  "HeaderTV": "Transfer.View",
  "HeaderKnowledge": "Knowledge.View"
};
var slTemplate = {
  "PathCommands": "Templates/SemaLogic/Commands",
  "PathSymTokenComparison": "Templates/SemaLogic/SymToken/Comparison",
  "PathSymTokenElements": "Templates/SemaLogic/SymToken/Elements",
  "PathSymTokenFunc": "Templates/SemaLogic/SymToken/FuncToken",
  "PathSymTokenMath": "Templates/SemaLogic/SymToken/Math",
  "PathSymTokenRefToken": "Templates/SemaLogic/SymToken/RefToken",
  "PathSymTokenTerms": "Templates/SemaLogic/SymToken/TermsAndRules",
  "PathExamplesBasic": "Templates/SemaLogic/Examples/Basic"
};

// src/utils.ts
var import_obsidian = require("obsidian");
var import_obsidian2 = require("obsidian");
var searchForSemaLogicCommands = (el) => {
  for (let i = 0; i < el.childNodes.length; i++) {
    const child = el.childNodes[i];
    if (isSemaLogicCommand(child)) {
      return true;
    }
  }
  return false;
};
var isSemaLogicCommand = (n) => {
  var _a;
  return n.nodeType === Node.TEXT_NODE && Boolean((_a = n.textContent) == null ? void 0 : _a.startsWith(semaLogicCommand.command_start));
};
var lastVersionNoticeKey;
var replaceWithEmptyNode = (containerEl) => {
  const results = [];
  return results;
};
async function replaceWithCommandNode(containerEl, settings) {
  var _a, _b;
  let results = [];
  let found = false;
  let semaLogicCom = (_b = containerEl.textContent) == null ? void 0 : _b.substring(semaLogicCommand.command_start.length, (_a = containerEl.textContent) == null ? void 0 : _a.indexOf(semaLogicCommand.command_end)).toLowerCase();
  if (!found && (semaLogicCom == null ? void 0 : semaLogicCom.toString().substring(0, semaLogicCommand.showHelp.length)) == semaLogicCommand.showHelp) {
    results = await showHelp();
    found = true;
  }
  if (!found && (semaLogicCom == null ? void 0 : semaLogicCom.toString().substring(0, semaLogicCommand.showVersion.length)) == semaLogicCommand.showVersion) {
    results = await showVersion(settings);
    found = true;
  }
  if (!found && (semaLogicCom == null ? void 0 : semaLogicCom.toString().substring(0, semaLogicCommand.showParse.length)) == semaLogicCommand.showParse) {
    let rulesettype = "";
    let filter = "";
    for (let rule in RulesettypesCommands) {
      if (semaLogicCom.contains(RulesettypesCommands[rule][0])) {
        rulesettype = RulesettypesCommands[rule][1];
        const findfor = semaLogicCom.indexOf(semaLogicCommand.showFilter);
        if (findfor > 0) {
          filter = semaLogicCom.substring(findfor + semaLogicCommand.showFilter.length);
          filter = filter.trim();
        }
        found = true;
        break;
      }
    }
    if (!found) {
      results = await showHelp();
      found = true;
    }
    if (rulesettype != "") {
      results = await showParseWithFilter(filter, rulesettype, settings);
    }
    found = true;
  }
  if (!found) {
    results = replaceWithEmptyNode(containerEl);
  }
  return results;
}
var SemaLogicRenderedElement = class extends import_obsidian.MarkdownRenderChild {
  constructor({ containerEl, set }) {
    super(containerEl);
    this.mysettings = set;
  }
  async onload() {
    this.containerEl.setChildrenInPlace(
      await replaceWithCommandNode(this.containerEl, this.mysettings)
    );
  }
};
async function showHelp() {
  let results = [];
  let buildcontainerEl;
  slconsolelog(DebugLevMap.DebugLevel_Informative, void 0, semaLogicCommand.showHelp);
  buildcontainerEl = createEl("table");
  let body = buildcontainerEl.createEl("body");
  let row = body.createEl("tr");
  row.createEl("td", { text: "SemaLogic-Commands-Help" });
  row.createEl("td", { text: "Description" });
  for (let i = 0; i < semaLogicHelp.length; i++) {
    const row2 = body.createEl("tr");
    row2.createEl("td", { text: semaLogicHelp[i][0] });
    row2.createEl("td", { text: semaLogicHelp[i][1] });
  }
  results.push(buildcontainerEl);
  return results;
}
async function showVersion(settings) {
  let results = [];
  let buildcontainerEl;
  let versiontext = "";
  slconsolelog(DebugLevMap.DebugLevel_Informative, void 0, semaLogicCommand.showVersion);
  const version = await semaLogicGetVersion(settings).then(function(resultBuffer) {
    versiontext = resultBuffer;
  }).catch(
    function(resultBuffer) {
      versiontext = resultBuffer;
    }
  );
  slconsolelog(DebugLevMap.DebugLevel_High, void 0, `JSON-Text in Processor:${versiontext}`);
  buildcontainerEl = createEl("table");
  const table = buildcontainerEl.createEl("table");
  const body = buildcontainerEl.createEl("body");
  const row = body.createEl("tr");
  row.createEl("td", { text: versiontext });
  results.push(buildcontainerEl);
  return results;
}
function sethttps(https) {
  let str;
  if (https) {
    str = API_Defaults.https;
  } else {
    str = API_Defaults.http;
  }
  return str;
}
function getHostPort(settings) {
  let adress = sethttps(settings.mySLSettings[settings.mySetting].myUseHttpsSL);
  adress = adress + settings.mySLSettings[settings.mySetting].myBaseURL;
  if (settings.mySLSettings[settings.mySetting].myPort != "") {
    adress = adress + ":" + settings.mySLSettings[settings.mySetting].myPort;
  }
  slconsolelog(DebugLevMap.DebugLevel_High, void 0, "getting SemaLogic-Adress: " + adress);
  return adress;
}
function getHostAspPort(settings, parsedCommands) {
  let adress;
  if (parsedCommands.outputformat == RulesettypesCommands[Rstypes_ASP][1]) {
    adress = sethttps(settings.mySLSettings[settings.mySetting].myUseHttps);
    adress = adress + settings.mySLSettings[settings.mySetting].myAspUrl;
    if (parsedCommands.endpoint != void 0) {
      if (parsedCommands.endpoint.indexOf("http") >= 0) {
        adress = parsedCommands.endpoint;
      } else {
        adress = adress + "/" + parsedCommands.endpoint;
      }
    }
  } else {
    adress = parsedCommands.endpoint;
  }
  if (parsedCommands.param != void 0 && parsedCommands.param != "") {
    adress = adress + "?" + parsedCommands.param;
  }
  slconsolelog(DebugLevMap.DebugLevel_High, void 0, "getting asp-Adress: " + adress);
  return adress;
}
async function semaLogicGetVersion(settings) {
  slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Start semaLogicGetVersion");
  const myVersion = '{"version":"0","versiontext":"Text"}';
  let myJson = JSON.parse(myVersion);
  let jsonVersion = "";
  let vAPI_URL_Version = getHostPort(settings) + API_Defaults.Version;
  slconsolelog(DebugLevMap.DebugLevel_Important, void 0, vAPI_URL_Version);
  let options;
  if (settings.mySLSettings[settings.mySetting].myUseHttpsSL && settings.mySLSettings[settings.mySetting].myUserSL != "") {
    options = {
      url: vAPI_URL_Version,
      method: "GET",
      headers: {
        "content-type": "application/json",
        "Authorization": "Basic " + btoa(settings.mySLSettings[settings.mySetting].myUserSL + ":" + settings.mySLSettings[settings.mySetting].myPasswordSL)
      }
    };
  } else {
    options = {
      url: vAPI_URL_Version,
      method: "GET"
    };
  }
  let response;
  try {
    response = await (0, import_obsidian2.requestUrl)(options);
    myJson = JSON.parse(response.text);
    slconsolelog(DebugLevMap.DebugLevel_All, void 0, myJson.version);
    jsonVersion = myJson.version;
    slconsolelog(DebugLevMap.DebugLevel_All, void 0, `JSON-Text in Request:${jsonVersion}`);
    return jsonVersion;
  } catch (e) {
    slconsolelog(DebugLevMap.DebugLevel_Error, void 0, "Error: Catch of APIVersion" + e.toString());
    throw new Error();
  }
}
async function semaLogicPing(settings, lastUpdate) {
  let starttime = Date.now();
  slconsolelog(DebugLevMap.DebugLevel_Informative, void 0, "GetVersionPing at ", Date.now(), "  for ", getHostPort(settings));
  await semaLogicGetVersion(settings).then(function(resultBuffer) {
    slconsolelog(DebugLevMap.DebugLevel_Informative, void 0, "SemaLogic GetVersionPing started at:", starttime, " Endtime: ", Date.now());
    const noticeKey = getHostPort(settings);
    if (noticeKey != lastVersionNoticeKey) {
      lastVersionNoticeKey = noticeKey;
      const ok = isApiVersionAtLeast(resultBuffer, "00.02.00");
      if (!ok) {
        new import_obsidian.Notice("UseSemaLogic requires a SemaLogic Service API version 00.02.00 or higher.");
      }
    }
  }).catch(
    function(e) {
      if (starttime < lastUpdate) {
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, `There is no connection to SemaLogicService APIVersion`);
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, getHostPort(settings));
        app.workspace.iterateAllLeaves((leaf) => {
          let slView = leaf.view.getViewType();
          if (slView == SemaLogicViewType) {
            const container = leaf.view.containerEl.children[1];
            container.empty();
            container.createEl("h3", { text: "SemaLogic_Error" });
            container.createEl("b", { text: "There is no connection to SemaLogicService -> APIVersion" });
            container.createEl("b", { text: getHostPort(settings) });
            return false;
          }
        });
      } else {
        slconsolelog(DebugLevMap.DebugLevel_High, void 0, "SemaLogic GetVersionPing failed and not used started:", starttime, " Endtime: ", Date.now());
      }
    }
  );
  return true;
}
function isApiVersionAtLeast(versionText, minVersion) {
  if (!versionText) {
    return false;
  }
  const extract = (v) => {
    const m = v.match(/(\d{2})\.(\d{2})\.(\d{2})/);
    if (!m) {
      return [];
    }
    return [parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10)];
  };
  const a = extract(versionText);
  const b = extract(minVersion);
  if (a.length !== 3 || b.length !== 3) {
    return false;
  }
  for (let i = 0; i < 3; i++) {
    if (a[i] > b[i]) {
      return true;
    }
    if (a[i] < b[i]) {
      return false;
    }
  }
  return true;
}
async function showParseWithFilter(filter, rulessettype, settings) {
  let results = [];
  let buildcontainerEl;
  let vAPI_URL = getHostPort(settings) + API_Defaults.rules_parse + "?sid=" + mygSID;
  slconsolelog(DebugLevMap.DebugLevel_Important, void 0, vAPI_URL);
  let bodytext = "";
  let activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
  if (activeView == void 0) {
    slconsolelog(DebugLevMap.DebugLevel_High, void 0, "Do not find an active view");
    return results;
  }
  let dialectID = "default";
  let codeblock = false;
  let newCodeblock = false;
  if (activeView != null) {
    for (let i = 0; i < activeView.editor.lineCount(); i++) {
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, i, ";", activeView.editor.getLine(i));
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, "Substring:", activeView.editor.getLine(i).substring(0, 2));
      if (activeView.editor.getLine(i).substring(0, 3) == "```") {
        if (!codeblock) {
          codeblock = true;
          newCodeblock = true;
        } else {
          newCodeblock = false;
        }
      }
      slconsolelog(DebugLevMap.DebugLevel_Informative, void 0, "Current line is Codeblock", codeblock);
      if (!codeblock && !newCodeblock) {
        switch (activeView.editor.getLine(i)) {
          default:
            bodytext = bodytext.concat(activeView.editor.getLine(i) + "\n");
        }
      } else {
        switch (activeView.editor.getLine(i).substring(0, semaLogicCommand.useDialect.length)) {
          case semaLogicCommand.useDialect: {
            dialectID = activeView.editor.getLine(i).substring(semaLogicCommand.useDialect.length, activeView.editor.getLine(i).length - 1);
            dialectID = dialectID.trim();
            break;
          }
          default: {
          }
        }
      }
      if (i < activeView.editor.lineCount()) {
        if (activeView.editor.getLine(i).substring(0, 3) == "```") {
          if (codeblock && !newCodeblock) {
            codeblock = false;
          } else {
            newCodeblock = false;
          }
        }
      }
    }
  }
  if (bodytext == "") {
    bodytext = "";
  }
  if (dialectID == "") {
    dialectID = "default";
  }
  let result = "";
  let optionsParse;
  if (filter != "") {
    let jsonwoFilter = {
      "text": [
        {
          "textID": "fly",
          "dialectID": dialectID,
          "rules": bodytext
        }
      ],
      "filter": {
        "dialectID": "default",
        "symbols": [
          {
            "symbol": filter
          }
        ]
      },
      "persistency": false,
      "rulesettype": rulessettype
    };
    optionsParse = {
      url: vAPI_URL,
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify(jsonwoFilter)
    };
  } else {
    let jsontestwthFilter = {
      "text": [
        {
          "textID": "fly",
          "dialectID": dialectID,
          "rules": bodytext
        }
      ],
      "filter": {},
      "persistency": false,
      "rulesettype": rulessettype
    };
    optionsParse = {
      url: vAPI_URL,
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify(jsontestwthFilter)
    };
  }
  let res;
  slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, `Context: ${dialectID}, Bodytext: ${bodytext}`);
  slconsolelog(DebugLevMap.DebugLevel_Important, void 0, optionsParse);
  try {
    const responseParse = await (0, import_obsidian2.requestUrl)(optionsParse);
    const remJson = responseParse.text;
    slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "SemaLogic: Parse with http-status " + responseParse.status.toString());
    if (responseParse.status == 200) {
      let resulthttp = responseParse.text;
      const fragment = new Range().createContextualFragment(resulthttp);
      buildcontainerEl = createEl("p");
      buildcontainerEl.appendChild(fragment);
      results.push(buildcontainerEl);
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, `Parseresult:${resulthttp}`);
      return results;
    }
  } catch (e) {
    slconsolelog(DebugLevMap.DebugLevel_Error, void 0, `Catcherror of removing context ${vAPI_URL}`);
    slconsolelog(DebugLevMap.DebugLevel_Error, void 0, e.toString());
    throw e;
  }
  return results;
}
function slconsolelog(DebugValue, slview, message, ...optionalParams) {
  if (DebugLevel >= DebugValue) {
    if (slview != void 0) {
      if (slview.getViewType() == SemaLogicViewType) {
        if (slview.getDebugInline() == true) {
          let logMessages = JSON.stringify(message);
          slview.appendDebugContent(logMessages);
        } else {
          console.log(message, ...optionalParams);
        }
      }
    } else {
      console.log(message, ...optionalParams);
    }
  }
}

// src/view_utils.ts
var ViewUtils = class {
  getContent(contentEl, outPutFormat) {
    let content;
    if (contentEl.textContent == null) {
      content = "";
    } else {
      content = contentEl.textContent;
    }
    content = this.cleanContent(content, outPutFormat);
    content = this.cleanCommands(content);
    return content;
  }
  cleanContent(content, outPutFormat) {
    if (outPutFormat == RulesettypesCommands[Rstypes_ASP][1]) {
      const firstJSONBracket = content.indexOf("{");
      content = content.substring(firstJSONBracket, content.length);
    }
    if (outPutFormat == RulesettypesCommands[Rstypes_Semalogic][1]) {
      const headerString = "Semalogic Output";
      const firstheaderString = content.indexOf(headerString);
      content = content.substring(firstheaderString + headerString.length, content.length);
    }
    return content;
  }
  cleanCommands(content) {
    let contentCleaned = [];
    let contentArray = content.split("\n");
    contentArray.forEach((element) => {
      let row = element.trim();
      row = row.toLowerCase();
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "Row before:" + row);
      row = row.replaceAll(" ", "");
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "Row after:" + row);
      if (row.indexOf(semaLogicCommand.command_start.toLowerCase()) != 0) {
        contentCleaned.push(element);
      } else {
        slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "Index Define:" + row.indexOf(semaLogicCommand.define).toString());
        slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "Length Start:" + semaLogicCommand.command_start.length.toString());
        if (row.indexOf(semaLogicCommand.define) == semaLogicCommand.command_start.length) {
          contentCleaned.push(element);
        }
      }
    });
    content = "";
    contentCleaned.forEach((element) => {
      content = content + element + "\n";
    });
    return content;
  }
};

// src/view.ts
var SemaLogicViewType = "SemaLogicService";
var SemaLogicView2 = class extends import_obsidian3.ItemView {
  constructor(leaf) {
    super(leaf);
    this.scaleRatio = 100;
    this.view_utils = new ViewUtils();
    this.debugInline = false;
    this.debugContent = [];
  }
  getOutPutFormat() {
    return this.dropdownButton.getValue();
  }
  getDebugInline() {
    return this.debugInline;
  }
  getContent() {
    return this.view_utils.getContent(this.contentEl, this.getOutPutFormat());
  }
  appendDebugContent(text) {
    this.debugContent.push(text);
  }
  copyToCb() {
    const blobcontentText = (cont) => `${cont}`;
    let data = new ClipboardItem({
      "text/plain": new Blob([blobcontentText(this.currResult)], {
        type: "text/plain"
      })
    });
    navigator.clipboard.write([data]).then(() => {
      alert("successfully copied");
    }).catch(() => {
      alert("something went wrong");
    });
  }
  setComm(comm) {
    if (this.slComm != comm) {
      this.slComm = comm;
      this.setNewInitial(this.slComm.slPlugin.settings.mySLSettings[this.slComm.slPlugin.settings.mySetting].myOutputFormat, false);
    }
  }
  getViewType() {
    return SemaLogicViewType;
  }
  getDisplayText() {
    return SemaLogicViewType;
  }
  onload() {
    this.navigation = true;
    this.contentEl.contentEditable = "true";
    this.debugInline == false;
  }
  getDebugButtonText() {
    if (this.debugInline == true) {
      return "InlineDebug is on";
    } else {
      return "InlineDebug is off";
    }
  }
  createDropDownButtonForOutPutFormat(container, dropDownValue) {
    this.dropdownButton = new import_obsidian3.DropdownComponent(container).addOption(RulesettypesCommands[Rstypes_Semalogic][1], RulesettypesCommands[Rstypes_Semalogic][0]).addOption(RulesettypesCommands[Rstypes_ASP][1], RulesettypesCommands[Rstypes_ASP][0]).addOption(RulesettypesCommands[Rstypes_Picture][1], RulesettypesCommands[Rstypes_Picture][0]).addOption(RulesettypesCommands[Rstypes_SemanticTree][1], RulesettypesCommands[Rstypes_SemanticTree][0]).addOption(RulesettypesCommands[Rstypes_KnowledgeGraph][1], RulesettypesCommands[Rstypes_KnowledgeGraph][0]).setValue(dropDownValue).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, "Set ViewOutputFormat: " + value);
      this.slComm.slPlugin.updateOutstanding = true;
      dropDownValue = value;
      this.dropdownButton.setValue(value);
      this.updateScaleControls(value);
      if (value == RulesettypesCommands[Rstypes_KnowledgeGraph][1]) {
        await this.slComm.slPlugin.activateKnowledgeView();
      }
      const responseForView = this.getSemaLogicParse(this.slComm.slPlugin.settings, this.apiURL, this.dialectID, this.bodytext, false, value);
      if (value == RulesettypesCommands[Rstypes_KnowledgeGraph][1]) {
        responseForView.then((result) => {
          this.slComm.slPlugin.updateKnowledgeCanvas(result);
        });
      }
    });
    return container;
  }
  createCopyToClipboardButton(container) {
    this.copyButton = new import_obsidian3.ButtonComponent(container).setButtonText("Copy to Clipboard").onClick((mouse_event) => {
      this.copyToCb();
    });
    return container;
  }
  createDebugButton(container) {
    if (DebugLevel != DebugLevMap.DebugLevel_Off) {
      this.debugButton = new import_obsidian3.ButtonComponent(container).setButtonText(this.getDebugButtonText()).onClick((mouse_event) => {
        if (this.debugInline == true) {
          this.debugInline = false;
          this.debugContent = [];
        } else {
          this.debugInline = true;
        }
        if (this.slComm.slview != void 0) {
          slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, "Set InlineDebugging: " + this.debugInline);
        }
        this.updateView();
      });
    }
    return container;
  }
  createScaleButtons(container) {
    this.zoomIn = new import_obsidian3.ButtonComponent(container).setButtonText("-").onClick((mouse_event) => {
      this.scaleRatio = this.scaleRatio / 2;
      if (this.zoomRatio != null) {
        this.zoomRatio.setButtonText(String(this.scaleRatio));
      }
      slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, "Set ScaleRatio to: " + this.scaleRatio);
      this.updateView();
    });
    this.zoomRatio = new import_obsidian3.ButtonComponent(container).setButtonText(String(this.scaleRatio)).onClick((mouse_event) => {
      slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, "ScaleRatio := " + this.scaleRatio);
    });
    this.zoomOut = new import_obsidian3.ButtonComponent(container).setButtonText("+").onClick((mouse_event) => {
      this.scaleRatio = this.scaleRatio * 2;
      this.zoomRatio.setButtonText(String(this.scaleRatio));
      slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, "Set ScaleRatio to: " + this.scaleRatio);
      this.updateView();
    });
    return container;
  }
  checkContainerContent() {
    var _a;
    if (this.containerEl.children != void 0) {
      if (((_a = this.containerEl.children[1].textContent) == null ? void 0 : _a.substring(0, slTexts["HeaderSL"].length)) == slTexts["HeaderSL"]) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
  deleteContainerContent() {
    if (this.containerEl.children != void 0) {
      for (let i = 0; i < this.containerEl.children.length; i++) {
        if (this.containerEl.children[i].nodeName == "p") {
          while (this.containerEl.children[i] != void 0) {
            this.containerEl.children[i].empty;
          }
        }
      }
    }
  }
  updateScaleControls(outputFormat) {
    if (this.scaleControlsEl == void 0) {
      this.scaleControlsEl = this.controlsEl.createEl("span");
      this.errorEl = this.contentEl.createEl("div", { cls: "semalogic-error" });
    }
    this.scaleControlsEl.empty();
    if (outputFormat == RulesettypesCommands[Rstypes_Picture][1]) {
      this.createScaleButtons(this.scaleControlsEl);
    }
  }
  setNewInitial(dropDownValue, now) {
    if (!this.checkContainerContent() || now || this.headerEl == void 0) {
      this.contentEl.empty();
      this.headerEl = this.contentEl.createEl("h4", { text: slTexts["HeaderSL"] });
      this.controlsEl = this.contentEl.createEl("div");
      this.scaleControlsEl = this.controlsEl.createEl("span");
      this.errorEl = this.contentEl.createEl("div", { cls: "semalogic-error" });
      this.resultEl = this.contentEl.createEl("div");
      this.createDropDownButtonForOutPutFormat(this.controlsEl, dropDownValue);
      this.createCopyToClipboardButton(this.controlsEl);
      this.createDebugButton(this.controlsEl);
      this.updateScaleControls(dropDownValue);
    } else {
      this.deleteContainerContent();
    }
  }
  async onOpen() {
    this.setNewInitial(RulesettypesCommands[Rstypes_Semalogic][1], false);
  }
  async onClose() {
  }
  showError(fragment) {
    if (this.errorEl == void 0) {
      this.errorEl = this.contentEl.createEl("div", { cls: "semalogic-error" });
    }
    this.errorEl.empty();
    this.errorEl.appendChild(fragment);
  }
  onunload() {
    if (this.slComm.slPlugin != void 0) {
      this.slComm.slPlugin.activated = false;
      this.slComm.slPlugin.myStatus.setText("SemaLogic is off");
    }
  }
  createSemaLogicRequestBody(dialectID, bodytext, outPutFormat) {
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, "Context: " + dialectID + " Bodytext: " + bodytext);
    let semaLogicJsonRequestBody = {
      "text": [
        {
          "textID": "ParsingOnTheFly",
          "dialectID": dialectID,
          "rules": bodytext
        }
      ],
      "filter": {},
      "persistency": false,
      "rulesettype": outPutFormat
    };
    return semaLogicJsonRequestBody;
  }
  createSemaLogicRequest(settings, vAPI_URL, semaLogicJsonRequestBody) {
    let request = {
      url: vAPI_URL,
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify(semaLogicJsonRequestBody)
    };
    if (settings.mySLSettings[settings.mySetting].myUseHttpsSL && settings.mySLSettings[settings.mySetting].myUserSL != "") {
      request = {
        url: vAPI_URL,
        method: "POST",
        headers: {
          "content-type": "application/json",
          "Authorization": "Basic " + btoa(settings.mySLSettings[settings.mySetting].myUserSL + ":" + settings.mySLSettings[settings.mySetting].myPasswordSL)
        },
        body: JSON.stringify(semaLogicJsonRequestBody)
      };
    }
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, "Parsingsstring");
    slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, semaLogicJsonRequestBody);
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, request);
    return request;
  }
  getRequestEmbed(content) {
    if (this.getOutPutFormat() == RulesettypesCommands[Rstypes_Picture][1]) {
      let viewBoxString;
      const beginVB = content.indexOf("viewBox");
      if (beginVB > 0) {
        const endVB = content.indexOf('"', content.indexOf('"', beginVB) + 1);
        viewBoxString = content.substring(beginVB, endVB + 1);
      } else {
        viewBoxString = 'viewBox = "0 0 16 9"';
      }
      content = content.replace("<body>", "");
      content = content.replace("</body>", "");
      let header;
      header = "<svg  " + viewBoxString + ' width = "' + String(this.scaleRatio) + '%" xmlns = "http://www.w3.org/2000/svg" >\n';
      header = header + content;
      header = header + "</svg>";
      return header;
    } else {
      return content;
    }
  }
  getCurrResult() {
    return this.getRequestEmbed(this.currResult);
  }
  getCurrHTML() {
    if (this.resultEl == void 0) {
      this.resultEl = this.contentEl.createEl("div");
    }
    let responseContent = this.resultEl.createEl("div");
    if (this.debugInline == true) {
      this.debugContent.forEach((value) => {
        const textline = responseContent.createEl("span", { text: value + "\n", cls: "debuginline" });
      });
    } else {
      if (this.getOutPutFormat() == RulesettypesCommands[Rstypes_ASP][1]) {
        let resulttextarray = this.getCurrResult().split("\n");
        resulttextarray.forEach((value) => {
          const textline = responseContent.createEl("span", { text: value + "\n", cls: "debuginline" });
        });
      } else {
        responseContent.createEl("p", { text: " " });
        responseContent.insertAdjacentHTML("afterend", this.getCurrResult());
      }
    }
  }
  updateView() {
    if (this.headerEl == void 0 || this.controlsEl == void 0 || this.resultEl == void 0) {
      this.setNewInitial(this.getOutPutFormat(), false);
    }
    this.updateScaleControls(this.getOutPutFormat());
    if (this.errorEl != void 0) {
      this.errorEl.empty();
    }
    if (this.resultEl != void 0) {
      this.resultEl.empty();
    }
    this.getCurrHTML();
  }
  async getSemaLogicParse(settings, vAPI_URL, dialectID, bodytext, parseOnTheFly, parsingFormat) {
    this.bodytext = bodytext;
    this.apiURL = vAPI_URL;
    this.dialectID = dialectID;
    let outPutFormat;
    let resulthttp;
    if (parsingFormat !== void 0) {
      outPutFormat = parsingFormat;
    } else {
      outPutFormat = this.getOutPutFormat();
    }
    let semaLogicJsonRequestBody = this.createSemaLogicRequestBody(dialectID, bodytext, outPutFormat);
    let semaLogicRequest = this.createSemaLogicRequest(settings, vAPI_URL, semaLogicJsonRequestBody);
    try {
      const response = await (0, import_obsidian3.requestUrl)(semaLogicRequest);
      slconsolelog(DebugLevMap.DebugLevel_High, this.slComm.slview, "SemaLogic: Parse with http-status " + response.status.toString());
      if (response.status == 200) {
        resulthttp = response.text;
        slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, `Parseresult:${resulthttp}`);
        if (this.debugInline == false && parseOnTheFly == false) {
          this.currResult = resulthttp;
        }
        if (!parseOnTheFly) {
          this.updateView();
        }
      }
      if (this.slComm.slaspview != void 0) {
      }
      return new Promise((resolve) => {
        resolve(resulthttp);
      });
    } catch (e) {
      slconsolelog(DebugLevMap.DebugLevel_Error, this.slComm.slview, `Request failed: ${semaLogicRequest.url}`);
      slconsolelog(DebugLevMap.DebugLevel_High, this.slComm.slview, `Catcherror of removing context ${vAPI_URL}`);
      slconsolelog(DebugLevMap.DebugLevel_High, this.slComm.slview, e.toString());
      let text = new DocumentFragment();
      text.createEl("p");
      let textfragment = new Range().createContextualFragment(e.toString());
      text.appendChild(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment("See for information about the error-code of http: https://de.wikipedia.org/wiki/HTTP-Statuscode ");
      text.append(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment(semaLogicRequest.url);
      text.append(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment(String(semaLogicRequest.body));
      text.append(textfragment);
      this.showError(text);
      throw e;
    }
  }
};

// src/view_asp.ts
var import_obsidian4 = require("obsidian");
var ASPViewType = "TransferService";
var ASPView = class extends import_obsidian4.ItemView {
  constructor(leaf) {
    super(leaf);
    this.LastRequestTime = 0;
    this.navigation = true;
    this.setNewASPInitial(true);
  }
  setComm(comm) {
    this.slComm = comm;
    this.setNewASPInitial(false);
  }
  getViewType() {
    return ASPViewType;
  }
  getDisplayText() {
    return ASPViewType;
  }
  onload() {
    this.navigation = true;
    this.contentEl.contentEditable = "true";
  }
  checkASPContainerContent() {
    var _a;
    if (this.containerEl.children != void 0) {
      if (((_a = this.containerEl.children[1].textContent) == null ? void 0 : _a.substring(0, slTexts["HeaderTV"].length)) == slTexts["HeaderTV"]) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
  deleteASPContainerContent() {
    if (this.containerEl.children != void 0) {
      for (let i = 0; i < this.containerEl.children.length; i++) {
        if (this.containerEl.children[i].nodeName == "p") {
          while (this.containerEl.children[i] != void 0) {
            this.containerEl.children[i].empty;
          }
        }
      }
    }
  }
  setNewASPInitial(now) {
    let container = this.contentEl;
    if (now || !this.checkASPContainerContent()) {
      container.empty();
      container.createEl("h4", { text: slTexts["HeaderTV"] });
      container.createEl("p");
    } else {
    }
  }
  async onOpen() {
  }
  async onClose() {
  }
  showError(fragment) {
    this.contentEl.appendChild(fragment);
  }
  onunload() {
    if (this.slComm != void 0) {
      this.slComm.slPlugin.activated = false;
      this.slComm.slPlugin.myStatus.setText("Transfer is off");
    }
  }
  createRequest(comm, settings, apiUrl, method, contentType, withBasicAuth, body) {
    let request;
    let myHeader = {};
    contentType = contentType.toLowerCase();
    method = method.toUpperCase();
    switch (contentType.toLowerCase()) {
      case "json": {
        myHeader["Content-Type"] = "application/json";
        break;
      }
      case "asp": {
        myHeader["Content-Type"] = "application/json";
        break;
      }
      case "asp.json": {
        myHeader["Content-Type"] = "application/json";
        break;
      }
      case "text": {
        myHeader["Content-Type"] = "text/plain";
        break;
      }
      default: {
        myHeader["Content-Type"] = contentType;
        break;
      }
    }
    if (withBasicAuth) {
      myHeader["Authorization"] = "Basic " + btoa(settings.mySLSettings[settings.mySetting].myUser + ":" + settings.mySLSettings[settings.mySetting].myPassword);
    }
    request = {
      url: apiUrl,
      method,
      headers: myHeader,
      body
    };
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, request);
    return request;
  }
  getASPCommands(slComm, settings) {
    let parseCommands;
    parseCommands = {
      commands: [{
        outputformat: "ASP.json",
        endpoint: settings.mySLSettings[settings.mySetting].myAspEndpoint,
        param: ""
      }]
    };
    let parseInitial = true;
    if (slComm.slview != null) {
      const editortext = slComm.slUsedMDView.editor.getRange({ line: 0, ch: 0 }, { line: slComm.slUsedMDView.editor.lastLine() + 1, ch: slComm.slUsedMDView.editor.lastLine.length });
      const rows = editortext.split("\n").filter((row) => row.length > 0);
      let myStrResult;
      let transferString;
      let endpointString = "";
      let paramString;
      rows.forEach((row) => {
        if (row.substring(0, semaLogicCommand.command_start.length) == semaLogicCommand.command_start) {
          const transfer = row.indexOf(semaLogicCommand.transfer);
          const endpoint = row.indexOf(semaLogicCommand.transferEndpoint);
          let param = row.indexOf(semaLogicCommand.transferParam);
          const endCommand = row.lastIndexOf(semaLogicCommand.command_end);
          if (param < 0) {
            param = endCommand;
          }
          if (transfer <= 0) {
          } else {
            transferString = row.substring(transfer + semaLogicCommand.transfer.length + 1, endpoint);
            transferString = transferString.trimEnd();
            if (endpoint > 0) {
              endpointString = row.substring(endpoint + 1 + semaLogicCommand.transferEndpoint.length, param);
              endpointString = endpointString.trimEnd();
            }
            if (param > 0 && param != endCommand) {
              paramString = row.substring(param + 1 + semaLogicCommand.transferParam.length, endCommand);
              paramString = paramString.trimEnd();
            }
            let paramParsedCommand = {
              outputformat: transferString,
              endpoint: endpointString,
              param: paramString
            };
            if (parseInitial) {
              parseInitial = false;
              parseCommands.commands[0] = paramParsedCommand;
            } else {
              parseCommands.commands.push(paramParsedCommand);
            }
          }
        }
      });
    }
    return parseCommands;
  }
  async aspParse(slComm, settings, aspJsonParsedSemaLogic, RequestTime) {
    slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, "Start Transfer_Parse");
    let vAPI_URL = "";
    const parseCommands = this.getASPCommands(slComm, settings);
    parseCommands.commands.forEach((parseCommands2) => {
      if (parseCommands2.outputformat == RulesettypesCommands[Rstypes_ASP][1] || parseCommands2.outputformat == RulesettypesCommands[Rstypes_ASP][0]) {
        vAPI_URL = getHostAspPort(settings, parseCommands2);
      } else {
        vAPI_URL = parseCommands2.endpoint;
        if (parseCommands2.param != void 0) {
          if (parseCommands2.param.length > 0) {
            vAPI_URL = vAPI_URL + "?" + parseCommands2.param;
          }
        }
        slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, "Transfer URL: ", vAPI_URL);
      }
      let optionsParse = this.createRequest(this.slComm, settings, vAPI_URL, "POST", "json", true, aspJsonParsedSemaLogic);
      this.Resp(optionsParse, vAPI_URL, RequestTime);
    });
  }
  async Resp(optionsParse, vAPI_URL, RequestTime) {
    try {
      slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, "ASP: want to parse ", optionsParse);
      const responseParse = await (0, import_obsidian4.requestUrl)(optionsParse);
      const remJson = responseParse.text;
      slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, "ASP: Parse with http-status " + responseParse.status.toString());
      if (responseParse.status == 200) {
        if (this.slComm.slaspview.LastRequestTime == RequestTime) {
          let resulthttp = responseParse.text;
          this.setNewASPInitial(true);
          this.contentEl.createEl("br");
          this.contentEl.createEl("span", "---------------------------------------------------------");
          this.contentEl.createEl("br");
          resulthttp = resulthttp.replaceAll("[", "[\n");
          resulthttp = resulthttp.replaceAll("]", "\n]");
          resulthttp = resulthttp.replaceAll(",", ",\n");
          let resulthttpArray = resulthttp.split("\n");
          resulthttpArray.forEach((element) => {
            this.contentEl.append(element);
            this.contentEl.createEl("br");
          });
          slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, `ASP-Parseresult:${resulthttp}`);
        } else {
          slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, `Old_ASP-Request: ${RequestTime} vs ${this.slComm.slaspview.LastRequestTime}`);
        }
      }
    } catch (e) {
      slconsolelog(DebugLevMap.DebugLevel_Error, this.slComm.slview, `Catcherror of removing context ${vAPI_URL}`);
      slconsolelog(DebugLevMap.DebugLevel_Error, this.slComm.slview, e.toString());
      let text = new DocumentFragment();
      text.createEl("p");
      let textfragment = new Range().createContextualFragment(e.toString());
      text.appendChild(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment("See for information about the error-code of http: https://de.wikipedia.org/wiki/HTTP-Statuscode ");
      text.append(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment(optionsParse.url);
      text.append(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment(String(optionsParse.body));
      text.append(textfragment);
      this.contentEl.empty();
      this.contentEl.createEl("br");
      this.contentEl.append(text);
    }
  }
};

// main.ts
var import_view4 = require("@codemirror/view");

// src/template.ts
var import_obsidian5 = require("obsidian");
async function createTemplateFolder(vault) {
  const templ = {
    folder: [
      {
        name: slTemplate["PathCommands"],
        files: [
          {
            name: "SL_Transfer",
            content: "SemaLogic(transfer %1 to endpoint %2 with param %3 )"
          },
          {
            name: "SL_ShowHelp",
            content: "SemaLogic(show help)"
          },
          {
            name: "SL_ShowVersion",
            content: "SemaLogic(show version)"
          },
          {
            name: "SL_TableDefine",
            content: "SemaLogic(define table)"
          },
          {
            name: "SL_Show",
            content: "SemaLogic(show as %1 for %2)"
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenComparison"],
        files: [
          {
            name: "SymTokenCompEqual",
            content: "=="
          },
          {
            name: "SymTokenCompGreater",
            content: ">"
          },
          {
            name: "SymTokenCompGreaterEqual",
            content: ">="
          },
          {
            name: "SymTokenCompLess",
            content: "<"
          },
          {
            name: "SymTokenCompLessEqual",
            content: "<="
          },
          {
            name: "SymTokenCompNotEqual",
            content: "!="
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenElements"],
        files: [
          {
            name: "SymTokenAnnounced",
            content: "%"
          },
          {
            name: "SymTokenAttribute",
            content: "$"
          },
          {
            name: "SymTokenCommentEnd",
            content: "*/"
          },
          {
            name: "SymTokenCommentStart",
            content: "/*"
          },
          {
            name: "SymTokenElement",
            content: ","
          },
          {
            name: "SymTokenEOL",
            content: "\n"
          },
          {
            name: "SymTokenEoS",
            content: ";"
          },
          {
            name: "SymTokenEqual",
            content: "\u2261"
          },
          {
            name: "SymTokenFilter",
            content: "\u25BC"
          },
          {
            name: "SymTokenGlobalMax",
            content: "+\u221E"
          },
          {
            name: "SymTokenGlobalMin",
            content: "-\u221E"
          },
          {
            name: "SymTokenIDDevider",
            content: "."
          },
          {
            name: "SymTokenInstance",
            content: "@"
          },
          {
            name: "SymTokenInterval",
            content: "|"
          },
          {
            name: "SymTokenLimit",
            content: "\u0141"
          },
          {
            name: "SymTokenLineComment",
            content: "//"
          },
          {
            name: "SymTokenReverseIDDevider",
            content: ":"
          },
          {
            name: "SymTokenSpace",
            content: " "
          },
          {
            name: "SymTokenVersion",
            content: "#"
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenFunc"],
        files: [
          {
            name: "FuncTokenCount",
            content: "Count"
          },
          {
            name: "FuncTokenMax",
            content: "Max"
          },
          {
            name: "FuncTokenMean",
            content: "Mean"
          },
          {
            name: "FuncTokenMin",
            content: "Min"
          },
          {
            name: "FuncTokenSum",
            content: "Sum"
          },
          {
            name: "FuncTokenUnDef",
            content: "_FuncUndef"
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenMath"],
        files: [
          {
            name: "SymTokenFunctionClose",
            content: ")"
          },
          {
            name: "SymTokenFunctionOpen",
            content: "("
          },
          {
            name: "SymTokenOpDivide",
            content: "/"
          },
          {
            name: "SymTokenOpMinus",
            content: "-"
          },
          {
            name: "SymTokenOpMultiply",
            content: "*"
          },
          {
            name: "SymTokenOpPlus",
            content: "+"
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenRefToken"],
        files: [
          {
            name: "RefTokenAll",
            content: "All"
          },
          {
            name: "RefTokenAnnounced",
            content: "Announced"
          },
          {
            name: "RefTokenChild",
            content: "Child"
          },
          {
            name: "RefTokenLeaf",
            content: "Leaf"
          },
          {
            name: "RefTokenRange",
            content: "Range"
          },
          {
            name: "RefTokenThis",
            content: "This"
          },
          {
            name: "RefTokenUnder",
            content: "Under"
          },
          {
            name: "RefTokenUsed",
            content: "Used"
          },
          {
            name: "RefTokenValue",
            content: "Value"
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenTerms"],
        files: [
          {
            name: "SymTokenAdviceClose",
            content: "!"
          },
          {
            name: "SymTokenAdviceOpen",
            content: "\xA1"
          },
          {
            name: "SymTokenAndClose",
            content: "]"
          },
          {
            name: "SymTokenAndOpen",
            content: "["
          },
          {
            name: "SymTokenCheckClose",
            content: "?"
          },
          {
            name: "SymTokenCheckOpen",
            content: "\xBF"
          },
          {
            name: "SymTokenDialectDefine",
            content: "\u2261"
          },
          {
            name: "SymTokenEqual",
            content: ":="
          },
          {
            name: "SymTokenGroup",
            content: "~"
          },
          {
            name: "SymTokenOrClose",
            content: "}"
          },
          {
            name: "SymTokenOrOpen",
            content: "{"
          },
          {
            name: "SymTokenTimeAfter",
            content: "\u21FD"
          },
          {
            name: "SymTokenTimeBefore",
            content: "\u21FE"
          },
          {
            name: "SymTokenTimeParallelAfter",
            content: "\u2962"
          },
          {
            name: "SymTokenTimeParallelBefore",
            content: "\u2964"
          }
        ]
      }
    ]
  };
  for (var myfolder = 0; myfolder < templ.folder.length; myfolder++) {
    for (var myfile = 0; myfile < templ.folder[myfolder].files.length; myfile++) {
      vault.createFolder(templ.folder[myfolder].name).catch((error) => console.log(error));
      vault.create(
        (0, import_obsidian5.normalizePath)(templ.folder[myfolder].name + "/" + templ.folder[myfolder].files[myfile].name + ".md"),
        templ.folder[myfolder].files[myfile].content
      ).catch((error) => console.log(error));
    }
  }
}

// src/examples.ts
var import_obsidian6 = require("obsidian");
async function createExamples(vault) {
  const templ = {
    folder: [
      {
        name: slTemplate["PathExamplesBasic"],
        files: [
          {
            name: "00_Overview",
            content: "In the next exmaple files there are a few and simple examples to use SemaLogic for biulding semantic logical rulesets. In general the examples should show the operating principle opf SemaLogic and have in mind that the characters of the syntax of the technical language could be replaced by formal (more natural) language as it shown in example from 30 up. \n\n0x - 1x: Simple rules and some of the functionalties\n2x - 3x: Cascading rules and combining with functions\n4x - 5x: Formal language examples\n8x     : Additional technical information for values and so on\n 9x     : Little Glossar for SymTokens\n\n\nPlease keep in mind that this examples are work in progress and we try to expand them to show all the functionality of SemaLogic in future releases of this plugin. \n\nWe also working on [our website](www.SemaLogic.de) - which is currently only available in german -  and are writing an official document for all syntax and structures you are able to use in SemaLogic now and about planned funtionalities. But we can not do everything at the same time.\n\nTechnical Information for using SemaLogic in obsidian: With ALT + T you can access to the SemaLogicToken-Templates !"
          },
          {
            name: "01_AND-Rules",
            content: "Defining a simple and-rule in standard technical language : A is true - if B,C and D are true \n\n---\n\nA [B, C, D]\n"
          },
          {
            name: "02_OR-Rules",
            content: "Defining a simple or-rule in standard technical language : A is true - if B,C or D are true \n\n---\n\nA 1|1 {B, C, D}\n\nIn an OR-Rule it is possible to define how many of the symbols (B,C,D) must be true with the number before and after the pipe-symbol.\n\nE 1|2 {E,F,G}\n\nThis OR-Rule means that one or two of the three symbols (E,F,G) must be true, so that E ist true. If none of the symbols is true or all of them, E will be false as well.\nIf you don't use from|to in an or-rule then it is replaced by from one to all symbols - what means that a minimum of one of the symbols has to be true so that E is true. "
          },
          {
            name: "03_Groups",
            content: "If you don't want to reuse some symbols with in different rule, it it possible to define groups which will be inserted in rules instead of the groups name\n\n---\n\nMyGroup ~ Elem1, Elem2, Elem3 ~\nMyOptions 1|1 {MyGroup}\n"
          },
          {
            name: "04_Dynamic groups",
            content: "It is also possible to define groups for using them in rules, even if you do not know which symbols are in by using an interval.Then the members of the group are defined by the rules dynamically.\n\n---\n\nMyGroup ~ Elem1|Elem4 ~\nElem2 [A,B]\nELem4 {C,D}\nMyOptions 1|1 {MyGroup}\n\nIn this case the ruleset only knows the symbols Elem2 and Elem4, which are inherited by the interval from Elem1 till Elem4. So the group is replaced by Eleem2 and Elem4.\n"
          },
          {
            name: "05_Time dependencies",
            content: "It it possible to define time dependencies for the used symbols. So the results have to be 'time ordered'. \n\n---\n\nA \u21FE B;\nThis means that in a solution A must be sorted before B and in combination with time lines it means that A have to be fullfilled completely before B begins.\n\nA \u2964 B;\nThis means that in a solution A must be sorted before B and in combination with time lines it means that A have to be fullfilled completely before B ends.\n\nIf you want to define this time dependencies vice versa you could use for after \u21FD or for parallel after \u2962.\n"
          },
          {
            name: "10_Values",
            content: "There are a lot of possibilites to put values to the attributes of a symbol or the symbol itself.\n\n---\n\nA.attrib \u2261 15\n\nThis statement will put a value of 15 to the attribute attrib of the symbol A. For example you can define a symbol Germany and put a tax rate to this symbol like Germay.Sales Tax = 19\n"
          },
          {
            name: "15_Using Tables",
            content: "You can reading tables in many different variants to upload rules and relations \n\n---\n\n   SemaLogic(Define Ntable, header((module_exam_number_\u2026), [exam_number_\u2026]), order(1, 2))\n\n| module_exam_number | exam_number |\n| ------------------ | ----------- |\n| 1032 | 10321 |\n| 1030 | 10311 |\n| 1021 | 10213 |\n| 1021 | 10215 |\n| 1021 | 10216 |\n\n "
          },
          {
            name: "20_Cascading rules",
            content: "It is possible to cascade rule only by using same symbolname for a new rule : \nA is true - if B or C is true; \nB is true - if B1 or B2 is true\n C is true - if C1 and C2 are true \n\n---\n\nA [B, C]\nB {B1 , B2}\nC [C1 , C2]"
          },
          {
            name: "40_Formal Language",
            content: "It is possible replace technical Symtokens for using formal language,\nso it ispossible to change dialects as you want with words you use - offical dialects are under development  \n\n---\n\nDas Studium besteht aus einer Abschlussarbeit und umfasst Fachsemester 1 bis Fachsemester 4 als Elemente.\n\n\nSymTokenSpace\u2261einer \nSymTokenSpace\u2261Das \nSymTokenInterval\u2261bis \nSymTokenGroup\u2261 umfasst\nSymTokenGroup\u2261 als Elemente\nSymTokenAndOpen\u2261 besteht aus\nSymTokenElement\u2261 und\nSymTokenAndClose\u2261.\nSymTokenOrClose\u2261.\n"
          }
        ]
      }
    ]
  };
  for (var myfolder = 0; myfolder < templ.folder.length; myfolder++) {
    for (var myfile = 0; myfile < templ.folder[myfolder].files.length; myfile++) {
      vault.createFolder(templ.folder[myfolder].name).catch((error) => console.log(error));
      vault.create(
        (0, import_obsidian6.normalizePath)(templ.folder[myfolder].name + "/" + templ.folder[myfolder].files[myfile].name + ".md"),
        templ.folder[myfolder].files[myfile].content
      ).catch((error) => console.log(error));
    }
  }
}

// src/test_canvas.ts
var import_obsidian7 = require("obsidian");
async function createTestCanvas(vault) {
  const canvasFolder = "SemaLogic";
  const hiddenInfoFolder = ".SemaLogic/test_nodeinfos";
  const infoFilePath = (0, import_obsidian7.normalizePath)(`${hiddenInfoFolder}/test-node.md`);
  const dataFilePath = (0, import_obsidian7.normalizePath)(`${hiddenInfoFolder}/test-node-data.md`);
  const canvasPath = (0, import_obsidian7.normalizePath)(`${canvasFolder}/TestCanvas.canvas`);
  await vault.createFolder(canvasFolder).catch(() => {
  });
  await vault.createFolder(hiddenInfoFolder).catch(() => {
  });
  const infoContent = "# Test Tooltip\n- Error 1\n- Error 2\n";
  const existingInfo = vault.getAbstractFileByPath(infoFilePath);
  if (existingInfo == null) {
    await vault.create(infoFilePath, infoContent).catch(() => {
    });
  } else {
    await vault.modify(existingInfo, infoContent).catch(() => {
    });
  }
  const dataContent = "# Test Data\n- Detail A\n- Detail B\n";
  const existingData = vault.getAbstractFileByPath(dataFilePath);
  if (existingData == null) {
    await vault.create(dataFilePath, dataContent).catch(() => {
    });
  } else {
    await vault.modify(existingData, dataContent).catch(() => {
    });
  }
  const canvasJson = {
    nodes: [
      {
        id: "n1",
        type: "text",
        text: "Hello Tooltip",
        x: 0,
        y: 0,
        width: 240,
        height: 80,
        meta: {
          SL_LinkedFile: infoFilePath,
          SL_DataFile: dataFilePath
        }
      },
      {
        id: "n2",
        type: "text",
        text: "Hello Data",
        x: 300,
        y: 0,
        width: 240,
        height: 80,
        meta: {
          SL_DataFile: dataFilePath
        }
      }
    ],
    edges: []
  };
  const existingCanvas = vault.getAbstractFileByPath(canvasPath);
  const canvasContent = JSON.stringify(canvasJson, null, 2);
  if (existingCanvas == null) {
    await vault.create(canvasPath, canvasContent).catch(() => {
    });
  } else {
    await vault.modify(existingCanvas, canvasContent).catch(() => {
    });
  }
}
async function createTemplateCanvas(vault) {
  const canvasFolder = "SemaLogic";
  const hiddenInfoFolder = ".SemaLogic/test_nodeinfos";
  const canvasPath = (0, import_obsidian7.normalizePath)(`${canvasFolder}/TemplateCanvas.canvas`);
  await vault.createFolder(canvasFolder).catch(() => {
  });
  await vault.createFolder(hiddenInfoFolder).catch(() => {
  });
  const files = [
    {
      path: ".SemaLogic/test_nodeinfos/kitchen-note.md",
      content: "# Kitchen Note (FILE)\n\nThis content is from the linked file, not the node text.\n\n## Errors\n- ERROR: Mock: missing TYPE for Stove\n- ERROR: Mock: duplicate NODEID in Rooms list\n\n## Hints\n- Check OR_MIN/OR_MAX for Liquid\u2218OR\n"
    },
    {
      path: ".SemaLogic/test_nodeinfos/liquid-note.md",
      content: "# Liquid OR (FILE)\n\nThis content is from the linked file, not the node text.\n\n## Errors\n- ERROR: Mock: OR_MAX missing\n- ERROR: Mock: OR_MIN must be >= 1\n"
    },
    {
      path: ".SemaLogic/test_nodeinfos/price-note.md",
      content: "# Price Assignment (FILE)\n\nThis content is from the linked file, not the node text.\n\n## Errors\n- ERROR: Mock: VALUE_TYPE missing\n- ERROR: Mock: negative VALUE not allowed\n"
    },
    {
      path: ".SemaLogic/test_nodeinfos/house-data.json",
      content: '{\n  "FILE_ONLY": "house-data.json",\n  "DATA": {\n    "SYMBOL": [\n      {\n        "ID": "ID-MyHouse-1",\n        "NODEID": "MyHouse",\n        "SYMBOL": "MyHouse",\n        "VALUE": "detached",\n        "VALUE_TYPE": "string",\n        "UNIT": "n/a",\n        "SOURCE": "template",\n        "CONFIDENCE": "0.84",\n        "ASSERTED_BY": "demo",\n        "TIMESTAMP": "2026-01-29T00:00:00Z"\n      }\n    ],\n    "TYPE": [\n      {\n        "ID": "ID-MyHouse-TYPE-1",\n        "TARGET_ID": "Building",\n        "TYPE": "Building",\n        "AS_DEFINED": "true"\n      }\n    ],\n    "PART_OF": [\n      {\n        "ID": "ID-MyHouse-PART-1",\n        "TARGET_ID": "Neighborhood",\n        "PART_OF": "Neighborhood"\n      }\n    ],\n    "RELATED_TO": [\n      {\n        "ID": "ID-MyHouse-REL-1",\n        "TARGET_ID": "Garage",\n        "RELATION": "near"\n      }\n    ],\n    "CONFIDENCE": [\n      {\n        "ID": "ID-MyHouse-CONF-1",\n        "CONFIDENCE": "0.84",\n        "SOURCE": "template"\n      }\n    ]\n  },\n  "FORWARD": {\n    "AND": [\n      {\n        "MyHouse\u2218AND": "NODE_PTR:0x0",\n        "ROLE": "subject",\n        "ORDER": "1",\n        "AS_DEFINED": "true"\n      }\n    ]\n  },\n  "BACKWARD": {\n    "SYMBOL": [\n      {\n        "Kitchen": "NODE_PTR:0x0",\n        "ROLE": "operand"\n      }\n    ]\n  },\n  "ERROR": {\n    "CONCEPT": [\n      {\n        "ERROR": "Mock: missing required TYPE for Garage",\n        "STATUS": "invalid",\n        "SOURCE": "validator"\n      }\n    ]\n  }\n}\n'
    },
    {
      path: ".SemaLogic/test_nodeinfos/car-data.json",
      content: '{\n  "FILE_ONLY": "car-data.json",\n  "DATA": {\n    "SYMBOL": [\n      {\n        "ID": "ID-Car-1",\n        "NODEID": "Addition",\n        "SYMBOL": "Car",\n        "VALUE": "4",\n        "VALUE_TYPE": "int",\n        "UNIT": "count",\n        "SOURCE": "template",\n        "TIMESTAMP": "2026-01-29T00:00:00Z"\n      }\n    ],\n    "MATH": [\n      {\n        "ID": "ID-Car-MATH-1",\n        "OPERATOR": "+",\n        "VALUE": "4",\n        "VALUE_TYPE": "int"\n      }\n    ]\n  },\n  "FORWARD": {\n    "SYMBOL": [\n      {\n        "Vehicle": "NODE_PTR:0x0",\n        "AS_DEFINED": "true"\n      }\n    ]\n  },\n  "BACKWARD": {\n    "TYPE": [\n      {\n        "Car\u2218TYPE": "NODE_PTR:0x0",\n        "ROLE": "subject"\n      }\n    ]\n  },\n  "ERROR": {\n    "CONCEPT": [\n      {\n        "ERROR": "Mock: value out of range",\n        "STATUS": "warning",\n        "SOURCE": "validator"\n      }\n    ]\n  }\n}\n'
    }
  ];
  for (const f of files) {
    const p = (0, import_obsidian7.normalizePath)(f.path);
    const existing = vault.getAbstractFileByPath(p);
    if (existing == null) {
      await vault.create(p, f.content).catch(() => {
      });
    } else {
      await vault.modify(existing, f.content).catch(() => {
      });
    }
  }
  const dataFiles = [
    { id: "Kitchen", file: ".SemaLogic/test_nodeinfos/kitchen-data.json" },
    { id: "Rooms", file: ".SemaLogic/test_nodeinfos/rooms-data.json" },
    { id: "Stairs", file: ".SemaLogic/test_nodeinfos/stairs-data.json" },
    { id: "Car", file: ".SemaLogic/test_nodeinfos/car-node-data.json" },
    { id: "Car\u2218TYPE", file: ".SemaLogic/test_nodeinfos/car-data.json" },
    { id: "Vehicle", file: ".SemaLogic/test_nodeinfos/vehicle-data.json" },
    { id: "House", file: ".SemaLogic/test_nodeinfos/house-data.json" },
    { id: "House\u2218AND", file: ".SemaLogic/test_nodeinfos/house-and-data.json" },
    { id: "084a3dde02011466", file: ".SemaLogic/test_nodeinfos/value2-data.json" },
    { id: "Price\u2218ASSIGNMENT", file: ".SemaLogic/test_nodeinfos/price-data.json" },
    { id: "Liquid", file: ".SemaLogic/test_nodeinfos/liquid-data.json" },
    { id: "Liquid\u2218OR", file: ".SemaLogic/test_nodeinfos/liquid-or-data.json" },
    { id: "Milk", file: ".SemaLogic/test_nodeinfos/milk-data.json" },
    { id: "581275de0cfc8acb", file: ".SemaLogic/test_nodeinfos/team-data.json" },
    { id: "2d2146e3b47553b2", file: ".SemaLogic/test_nodeinfos/team-group-data.json" },
    { id: "9a60b2e40aa59e5c", file: ".SemaLogic/test_nodeinfos/member-b-data.json" },
    { id: "8d55e0c369378e10", file: ".SemaLogic/test_nodeinfos/member-a-data.json" },
    { id: "92f71bd69b9476af", file: ".SemaLogic/test_nodeinfos/team-leaf-data.json" }
  ];
  for (const df of dataFiles) {
    const payload = JSON.stringify(
      { FILE_ONLY: df.file, NODE_ID: df.id, SOURCE: "template" },
      null,
      2
    ) + "\n";
    const existing = vault.getAbstractFileByPath(df.file);
    if (existing == null) {
      await vault.create(df.file, payload).catch(() => {
      });
    } else {
      await vault.modify(existing, payload).catch(() => {
      });
    }
  }
  const canvasJson = {
    nodes: [
      { id: "Kitchen", type: "text", text: "## NodeID: Kitchen\nCONCEPT: SYMBOL\nERROR: Mock: missing TYPE for Stove", x: -1140, y: 440, width: 260, height: 120, color: "#6FA8DC", meta: { SL_LinkedFile: ".SemaLogic/test_nodeinfos/kitchen-note.md", SL_DataFile: ".SemaLogic/test_nodeinfos/kitchen-data.json" } },
      { id: "Rooms", type: "text", text: "## NodeID: Rooms\nCONCEPT: SYMBOL", x: -900, y: 440, width: 260, height: 120, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/rooms-data.json" } },
      { id: "Stairs", type: "text", text: "## NodeID: Stairs\nCONCEPT: SYMBOL", x: -660, y: 440, width: 260, height: 120, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/stairs-data.json" } },
      { id: "Car", type: "text", text: "## NodeID: Addition\nCONCEPT: SYMBOL", x: 360, y: 0, width: 260, height: 120, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/car-node-data.json" } },
      { id: "Car\u2218TYPE", type: "text", text: "## NodeID: Car\u2218MATH\nCONCEPT: MATH\nOPERATOR: +", x: 360, y: 200, width: 260, height: 140, color: "#93C47D", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/car-data.json" } },
      { id: "Vehicle", type: "text", text: "## NodeID: Value1\nCONCEPT: SYMBOL\nVALUE: 4", x: 360, y: 420, width: 260, height: 200, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/vehicle-data.json" } },
      { id: "House", type: "text", text: "## NodeID: MyHouse\nCONCEPT: SYMBOL", x: -1030, y: -600, width: 300, height: 120, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/house-data.json" } },
      { id: "House\u2218AND", type: "text", text: "## NodeID: MyHouse\u2218AND\nCONCEPT: AND", x: -1010, y: -320, width: 370, height: 120, color: "#F6B26B", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/house-and-data.json" } },
      { id: "084a3dde02011466", type: "text", text: "## NodeID: Value2\nCONCEPT: SYMBOL", x: 660, y: 420, width: 260, height: 200, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/value2-data.json" } },
      { id: "Price\u2218ASSIGNMENT", type: "text", text: "## NodeID: Price\u2218ASSIGNMENT\nCONCEPT: ASSIGNMENT\nVALUE: 5\nERROR: Mock: VALUE_TYPE missing", x: 660, y: 720, width: 320, height: 180, color: "#B4A7D6", meta: { SL_LinkedFile: ".SemaLogic/test_nodeinfos/price-note.md", SL_DataFile: ".SemaLogic/test_nodeinfos/price-data.json" } },
      { id: "Liquid", type: "text", text: "## NodeID: Liquid\nCONCEPT: SYMBOL", x: -120, y: -220, width: 300, height: 140, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/liquid-data.json" } },
      { id: "Liquid\u2218OR", type: "text", text: "## NodeID: Liquid\u2218OR\nCONCEPT: OR\nOR_MIN: <int>\nOR_MAX: <int>\nERROR: Mock: OR_MAX missing", x: -120, y: 0, width: 300, height: 160, color: "#FFD966", meta: { SL_LinkedFile: ".SemaLogic/test_nodeinfos/liquid-note.md", SL_DataFile: ".SemaLogic/test_nodeinfos/liquid-or-data.json" } },
      { id: "Water", type: "text", text: "## NodeID: Water\nCONCEPT: SYMBOL", x: 0, y: 240, width: 220, height: 120, color: "#6FA8DC" },
      { id: "Milk", type: "text", text: "## NodeID: Milk\nCONCEPT: SYMBOL", x: -300, y: 240, width: 220, height: 120, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/milk-data.json" } },
      { id: "581275de0cfc8acb", type: "text", text: "## NodeID: Team\nCONCEPT: SYMBOL", x: 1100, y: -320, width: 300, height: 140, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/team-data.json" } },
      { id: "2d2146e3b47553b2", type: "text", text: "## NodeID: Team\u2218GROUP\nCONCEPT: GROUP", x: 1100, y: -100, width: 300, height: 160, color: "#FFD966", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/team-group-data.json" } },
      { id: "9a60b2e40aa59e5c", type: "text", text: "## NodeID: MEMBER B\nCONCEPT: SYMBOL", x: 1220, y: 140, width: 300, height: 120, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/member-b-data.json" } },
      { id: "8d55e0c369378e10", type: "text", text: "## NodeID: Member A\nCONCEPT: SYMBOL", x: 820, y: 140, width: 320, height: 120, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/member-a-data.json" } },
      { id: "92f71bd69b9476af", type: "text", text: "## NodeID: Team\u2218LEAF\nCONCEPT: LEAF", x: 1560, y: -100, width: 300, height: 140, color: "#6FA8DC", meta: { SL_DataFile: ".SemaLogic/test_nodeinfos/team-leaf-data.json" } }
    ],
    edges: [
      { id: "House->House\u2218AND", fromNode: "House", fromSide: "bottom", toNode: "House\u2218AND", toSide: "top" },
      { id: "House\u2218AND->Kitchen", fromNode: "House\u2218AND", fromSide: "bottom", toNode: "Kitchen", toSide: "top" },
      { id: "House\u2218AND->Rooms", fromNode: "House\u2218AND", fromSide: "bottom", toNode: "Rooms", toSide: "top" },
      { id: "House\u2218AND->Stairs", fromNode: "House\u2218AND", fromSide: "bottom", toNode: "Stairs", toSide: "top" },
      { id: "Liquid->Liquid\u2218OR", fromNode: "Liquid", fromSide: "bottom", toNode: "Liquid\u2218OR", toSide: "top" },
      { id: "Liquid\u2218OR->Milk", fromNode: "Liquid\u2218OR", fromSide: "bottom", toNode: "Milk", toSide: "top" },
      { id: "Liquid\u2218OR->Water", fromNode: "Liquid\u2218OR", fromSide: "bottom", toNode: "Water", toSide: "top" },
      { id: "Car->Car\u2218TYPE", fromNode: "Car", fromSide: "bottom", toNode: "Car\u2218TYPE", toSide: "top" },
      { id: "Car\u2218TYPE->Vehicle", fromNode: "Car\u2218TYPE", fromSide: "bottom", toNode: "Vehicle", toSide: "top" },
      { id: "04d8896a15577c08", fromNode: "Car\u2218TYPE", fromSide: "bottom", toNode: "084a3dde02011466", toSide: "top" },
      { id: "653be9449f30aac1", fromNode: "084a3dde02011466", fromSide: "bottom", toNode: "Price\u2218ASSIGNMENT", toSide: "top" },
      { id: "1f598ed5a361ea28", fromNode: "581275de0cfc8acb", fromSide: "bottom", toNode: "2d2146e3b47553b2", toSide: "top" },
      { id: "fd4430f4602cdb55", fromNode: "2d2146e3b47553b2", fromSide: "bottom", toNode: "8d55e0c369378e10", toSide: "top" },
      { id: "355ee84b5a367f91", fromNode: "2d2146e3b47553b2", fromSide: "bottom", toNode: "9a60b2e40aa59e5c", toSide: "top" },
      { id: "46958cf1a30f7212", fromNode: "581275de0cfc8acb", fromSide: "bottom", toNode: "92f71bd69b9476af", toSide: "top" }
    ]
  };
  const existingCanvas = vault.getAbstractFileByPath(canvasPath);
  const canvasContent = JSON.stringify(canvasJson, null, 2);
  if (existingCanvas == null) {
    await vault.create(canvasPath, canvasContent).catch(() => {
    });
  } else {
    await vault.modify(existingCanvas, canvasContent).catch(() => {
    });
  }
}

// src/sl_term_hider.ts
var import_view2 = require("@codemirror/view");
var import_state = require("@codemirror/state");
function decodeSLTerm(b64) {
  try {
    const bin = atob(b64);
    const pct = Array.from(bin, (c) => "%" + c.charCodeAt(0).toString(16).padStart(2, "0")).join("");
    return decodeURIComponent(pct);
  } catch (e) {
    return "";
  }
}
var SLHintWidget = class extends import_view2.WidgetType {
  constructor(term, view, selFrom, selTo) {
    super();
    this.term = term;
    this.view = view;
    this.selFrom = selFrom;
    this.selTo = selTo;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "sl-term-hint";
    span.textContent = "\u24D8";
    span.title = this.term;
    span.addEventListener("click", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      try {
        this.view.dispatch({
          selection: { anchor: this.selFrom, head: this.selTo },
          scrollIntoView: true
        });
      } catch (e) {
      }
      document.dispatchEvent(new CustomEvent("sl-interpreter"));
    });
    return span;
  }
};
var SL_TERM_REGEX = /(.+?)\s*\((SL64|SL):([^)]+)\)/g;
var slTermHider = import_view2.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.buildDecorations(view);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged) {
      this.decorations = this.buildDecorations(update.view);
    }
  }
  buildDecorations(view) {
    var _a, _b, _c;
    const builder = new import_state.RangeSetBuilder();
    const text = view.state.doc.toString();
    let match;
    while ((match = SL_TERM_REGEX.exec(text)) !== null) {
      const matchText = match[0];
      const from = match.index;
      const to = from + matchText.length;
      const orig = (_a = match[1]) != null ? _a : "";
      const mode = (_b = match[2]) != null ? _b : "SL";
      const rawTerm = (_c = match[3]) != null ? _c : "";
      let term = rawTerm;
      if (mode === "SL64") {
        term = decodeSLTerm(rawTerm);
      } else {
        term = rawTerm.replace(/\\\)/g, ")").replace(/\\\(/g, "(").replace(/\\\\/g, "\\");
      }
      const endBracket = matchText.indexOf("]");
      if (endBracket >= 0) {
        builder.add(from, from + endBracket + 1, import_view2.Decoration.mark({ class: "sl-term-origin" }));
      }
      const slIndex = matchText.indexOf("(" + mode + ":");
      if (slIndex >= 0) {
        const slFrom = from + slIndex;
        const slTo = to;
        const origFrom = from + 1;
        const origTo = from + endBracket;
        builder.add(slFrom, slTo, import_view2.Decoration.replace({ widget: new SLHintWidget(term, view, origFrom, origTo) }));
      } else {
        const origFrom = from + 1;
        const origTo = from + endBracket;
        builder.add(from, to, import_view2.Decoration.replace({ widget: new SLHintWidget(term, view, origFrom, origTo) }));
      }
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});

// main.ts
var DebugLevel = 0;
var mygSID = String(Math.round(Math.random() * 99999999999));
var Default_profile = {
  mySLSettings: [
    {
      myPort: API_Defaults.Port,
      myOutputFormat: "SemaLogic",
      myBaseURL: API_Defaults.Base_URL,
      myGetAPI: API_Defaults.GetAPI,
      mySID: API_Defaults.SID,
      myContext: API_Defaults.ShowContext,
      myUseHttps: API_Defaults.useUserPasswortforHTTP,
      myUser: API_Defaults.HttpUser,
      myPassword: API_Defaults.HttpPassword,
      myUpdateInterval: Value_Defaults.updateInterval,
      myAspUrl: API_Defaults.AspUrl,
      myAspEndpoint: API_Defaults.AspEndpoint,
      myUseHttpsSL: API_Defaults.useUserPasswortforHTTPSL,
      myUserSL: API_Defaults.HttpUserSL,
      myPasswordSL: API_Defaults.HttpPasswordSL
    },
    {
      myPort: API_Defaults.Port,
      myOutputFormat: "SemaLogic",
      myBaseURL: API_Defaults.Base_URL,
      myGetAPI: API_Defaults.GetAPI,
      mySID: API_Defaults.SID,
      myContext: API_Defaults.ShowContext,
      myUseHttps: API_Defaults.useUserPasswortforHTTP,
      myUser: API_Defaults.HttpUser,
      myPassword: API_Defaults.HttpPassword,
      myUpdateInterval: Value_Defaults.updateInterval,
      myAspUrl: API_Defaults.AspUrl,
      myAspEndpoint: API_Defaults.AspEndpoint,
      myUseHttpsSL: API_Defaults.useUserPasswortforHTTPSL,
      myUserSL: API_Defaults.HttpUserSL,
      myPasswordSL: API_Defaults.HttpPasswordSL
    },
    {
      myPort: API_Defaults.Port,
      myOutputFormat: "SemaLogic",
      myBaseURL: API_Defaults.Base_URL,
      myGetAPI: API_Defaults.GetAPI,
      mySID: API_Defaults.SID,
      myContext: API_Defaults.ShowContext,
      myUseHttps: API_Defaults.useUserPasswortforHTTP,
      myUser: API_Defaults.HttpUser,
      myPassword: API_Defaults.HttpPassword,
      myUpdateInterval: Value_Defaults.updateInterval,
      myAspUrl: API_Defaults.AspUrl,
      myAspEndpoint: API_Defaults.AspEndpoint,
      myUseHttpsSL: API_Defaults.useUserPasswortforHTTPSL,
      myUserSL: API_Defaults.HttpUserSL,
      myPasswordSL: API_Defaults.HttpPasswordSL
    }
  ],
  mySetting: 0,
  myDebugLevel: 0
};
var SemaLogicSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for SemaLogic:" });
    new import_obsidian8.Setting(containerEl).setName("General DebugLevel").setDesc("You can set a DebugLevel for Developmentinformation").addDropdown((dropDown) => dropDown.addOption("0", DebugLevelNames[0]).addOption("1", DebugLevelNames[1]).addOption("2", DebugLevelNames[2]).addOption("3", DebugLevelNames[3]).addOption("4", DebugLevelNames[4]).addOption("5", DebugLevelNames[5]).setValue(String(this.plugin.settings.myDebugLevel)).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_High, void 0, "Set DebugLevel: " + DebugLevelNames[parseInt(value)]);
      this.plugin.settings.myDebugLevel = parseInt(value);
      DebugLevel = parseInt(value);
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian8.Setting(containerEl).setName("Change your setting profile").setDesc("You can define different profiles for your SemaLogicService").addDropdown((dropDown) => dropDown.addOption("0", "Profile 1").addOption("1", "Profile 2").addOption("2", "Profile 3").setValue(this.plugin.settings.mySetting.toString()).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_High, void 0, "Set Profile: " + value);
      this.plugin.settings.mySetting = parseInt(value);
      this.display();
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Standard updateinterval").addText((setting) => setting.setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUpdateInterval.toString()).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set Update Interval: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUpdateInterval = parseInt(value);
      window.clearInterval(this.plugin.interval);
      this.plugin.registerInterval(
        this.plugin.interval = 0
      );
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("BaseUrl").setDesc("BaseURL for reaching SemaLogicService").addText((text) => text.setPlaceholder(API_Defaults.Base_URL).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myBaseURL).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set BaseURL: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myBaseURL = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Path to Get-API-Endpoints").setDesc("Path to Get-API for more Information about the Endpoints of used APIs").addText((text) => text.setPlaceholder(API_Defaults.GetAPI).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myGetAPI).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set to Get-API-Endpoint: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myGetAPI = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Port SemaLogic").setDesc("Enter the Port").addText((text) => text.setPlaceholder(API_Defaults.Port).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPort).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set to Port: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPort = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("OutputFormat").setDesc("Here you can set the outputformat for SemaLogic, which could be get from SemaLogicService").addDropdown((dropDown) => dropDown.addOption(RulesettypesCommands[Rstypes_Semalogic][1], RulesettypesCommands[Rstypes_Semalogic][0]).addOption(RulesettypesCommands[Rstypes_ASP][1], RulesettypesCommands[Rstypes_ASP][0]).addOption(RulesettypesCommands[Rstypes_Picture][1], RulesettypesCommands[Rstypes_Picture][0]).addOption(RulesettypesCommands[Rstypes_SemanticTree][1], RulesettypesCommands[Rstypes_SemanticTree][0]).addOption(RulesettypesCommands[Rstypes_KnowledgeGraph][1], RulesettypesCommands[Rstypes_KnowledgeGraph][0]).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myOutputFormat).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set Outputformat: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myOutputFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Secure HTTP-Request SemaLogic").setDesc("If you has to use User/Password for http-request to the semalogic service").addToggle((setting) => setting.setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttpsSL).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set UserPasswordRequest: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttpsSL = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttpsSL) {
      new import_obsidian8.Setting(containerEl).setName("HTTP-Request-User").setDesc("User to reach transfer service").addText((text) => text.setPlaceholder(API_Defaults.HttpUserSL).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUserSL).onChange(async (value) => {
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set HTTP-Request-User...");
        this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUserSL = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian8.Setting(containerEl).setName("HTTP-Request-Password").setDesc("Password to reach transfer service").addText((text) => text.setPlaceholder(API_Defaults.HttpPasswordSL).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPasswordSL).onChange(async (value) => {
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set HTTP-Request-Password...");
        this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPasswordSL = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian8.Setting(containerEl).setName("Show Context in Reading View").addToggle((setting) => setting.setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myContext).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set Context of Reading View: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myContext = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h1", { text: "_______________________________" });
    containerEl.createEl("h2", { text: "Settings for Transfer/ASP-View:" });
    new import_obsidian8.Setting(containerEl).setName("BaseUrl for Transfer/ASP").setDesc("BaseURL for reaching Transfer/ASP-Service").addText((text) => text.setPlaceholder(API_Defaults.AspUrl).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myAspUrl).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set Transfer/ASP-BaseURL: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myAspUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Path to Get-Transfer/ASP-StandardAPI-Endpoint").setDesc("Path to Transfer/ASP-Standard-API ").addText((text) => text.setPlaceholder(API_Defaults.AspEndpoint).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myAspEndpoint).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set to Transfer/ASP-Standard-API-Endpoint: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myAspEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Secure HTTP-Request").setDesc("If you has to use User/Password for http-request to the transfer service").addToggle((setting) => setting.setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttps).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set UserPasswordRequest: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttps = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttps) {
      new import_obsidian8.Setting(containerEl).setName("HTTP-Request-User").setDesc("User to reach transfer service").addText((text) => text.setPlaceholder(API_Defaults.HttpUser).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUser).onChange(async (value) => {
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set HTTP-Request-User...");
        this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUser = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian8.Setting(containerEl).setName("HTTP-Request-Password").setDesc("Password to reach transfer service").addText((text) => text.setPlaceholder(API_Defaults.HttpPassword).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPassword).onChange(async (value) => {
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set HTTP-Request-Password...");
        this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPassword = value;
        await this.plugin.saveSettings();
      }));
    }
  }
};
var SemaLogicPluginComm2 = class {
  constructor() {
    this.activatedASP = false;
    this.activatedKnowledge = false;
  }
  setSlView(view) {
    this.slview = view;
  }
  setSLClass(slclass) {
    this.slPlugin = slclass;
  }
  add(a, b) {
    return a + b;
  }
};
var SemaLogicPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.statusTransfer = false;
    this.statusSL = true;
    this.pluginEnabled = true;
    this.activated = false;
    this.updating = false;
    this.lastUpdate = 0;
    this.updateOutstanding = false;
    this.updateTransferOutstanding = false;
    this.updateOutstandingSetting = false;
    this.waitingForResponse = false;
    this.UpdateProcessing = false;
    this.view_utils = new ViewUtils();
    this.lastParsedHash = "";
    this.canvasTooltipObservers = /* @__PURE__ */ new WeakMap();
    this.canvasNodeFileCache = /* @__PURE__ */ new Map();
    this.knowledgeCanvasPath = "SemaLogic/KnowledgeGraph.canvas";
    this.knowledgeLastRequestTime = 0;
    this.knowledgeEditCanvasPath = "SemaLogic/KnowledgeEdit.canvas";
    this.knowledgeEditLastCanvas = "";
    this.interpreterCanvasPath = "SemaLogic/SLInterpreter.canvas";
    this.interpreterLastCanvas = "";
    this.pauseAllRequests = false;
    this.handleUpdate = (update) => {
      if (this.pauseAllRequests) {
        return;
      }
      if (this.statusSL) {
        if (update == null) {
        } else {
          if (update.view) {
            if (!update.docChanged && !update.focusChanged) {
              return;
            } else {
              if (this.parseDebounce != void 0) {
                window.clearTimeout(this.parseDebounce);
              }
              this.parseDebounce = window.setTimeout(() => {
                this.semaLogicUpdate();
              }, 400);
            }
          }
        }
      }
    };
  }
  getContextFromLine(mydialectID) {
    mydialectID = mydialectID.replace("SemaLogicContext\u2261", "SemaLogicDialect\u2261");
    let re = /\t/gi;
    mydialectID = mydialectID.replace(re, "");
    re = /\n/gi;
    mydialectID = mydialectID.replace(re, "");
    return { mydialectID };
  }
  getActiveView() {
    const activeView = app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
    if (activeView === null) {
      if (this.lastactiveView === null) {
        slconsolelog(DebugLevMap.DebugLevel_High, this.slComm.slview, "ActiveView could not be defined through SemaLogic");
        return;
      } else {
        return this.lastactiveView;
      }
    }
    this.lastactiveView = activeView;
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, this.lastactiveView.getDisplayText());
    return this.lastactiveView;
  }
  setViews() {
    var _a;
    this.slComm.activatedASP = false;
    this.app.workspace.iterateAllLeaves((leaf) => {
      switch (leaf.view.getViewType()) {
        case SemaLogicViewType: {
          this.slComm.slview = leaf.view;
          this.slComm.slview.setComm(this.slComm);
          this.slComm.slview.slComm.setSlView(this.slComm.slview);
          this.slComm.slview.slComm.slPlugin = this.slComm.slPlugin;
          this.activated = true;
          this.statusSL = true;
          break;
        }
        case ASPViewType: {
          this.slComm.slaspview = leaf.view;
          this.slComm.slaspview.setComm(this.slComm);
          this.slComm.slaspview.slComm.setSlView(this.slComm.slview);
          this.slComm.slaspview.slComm.slPlugin = this.slComm.slPlugin;
          this.slComm.activatedASP = true;
          this.statusTransfer = true;
          break;
        }
      }
    });
    this.slComm.activatedKnowledge = this.knowledgeLeaf != void 0 || this.findKnowledgeCanvasLeaf() != void 0;
    slconsolelog(DebugLevMap.DebugLevel_Current_Dev, (_a = this.slComm) == null ? void 0 : _a.slview, "Knowledge active: " + String(this.slComm.activatedKnowledge));
    this.getActiveView();
  }
  async onload() {
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
      if (!this.pluginEnabled) {
        return;
      }
      const selection = editor.getSelection();
      if (!selection || selection.length == 0) {
        return;
      }
      menu.addItem((item) => {
        item.setTitle("Edit in SL-Graph").onClick(() => {
          this.startKnowledgeEdit(view, selection);
        });
      });
      menu.addItem((item) => {
        item.setTitle("SL-Interpreter").onClick(() => {
          this.startSLInterpreter(view, selection);
        });
      });
    }));
    this.registerEvent(this.app.workspace.on("layout-change", () => {
      this.attachCanvasTooltipsToAllLeaves();
      if (this.knowledgeEditLeaf != void 0 && this.findKnowledgeEditLeaf() == void 0) {
        this.stopKnowledgeEdit();
      }
      if (this.interpreterLeaf != void 0 && this.findInterpreterLeaf() == void 0) {
        this.stopSLInterpreter();
      }
    }));
    this.registerEvent(this.app.vault.on("modify", (file) => {
      const path = (0, import_obsidian8.normalizePath)(file.path);
      if (path == (0, import_obsidian8.normalizePath)(this.knowledgeEditCanvasPath)) {
        if (!this.pauseAllRequests || this.knowledgeEditSelection == void 0) {
          return;
        }
        if (this.knowledgeEditDebounce != void 0) {
          window.clearTimeout(this.knowledgeEditDebounce);
        }
        this.knowledgeEditDebounce = window.setTimeout(() => {
          this.tickKnowledgeEdit();
        }, 300);
      }
      if (path == (0, import_obsidian8.normalizePath)(this.interpreterCanvasPath)) {
        if (!this.pauseAllRequests || this.interpreterSelection == void 0) {
          return;
        }
        if (this.interpreterDebounce != void 0) {
          window.clearTimeout(this.interpreterDebounce);
        }
        this.interpreterDebounce = window.setTimeout(() => {
          this.tickSLInterpreter();
        }, 300);
      }
    }));
    this.registerDomEvent(document, "sl-interpreter", () => {
      if (!this.pluginEnabled || this.pauseAllRequests) {
        return;
      }
      const view = this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
      if (!view) {
        return;
      }
      const selection = view.editor.getSelection();
      if (!selection || selection.length == 0) {
        return;
      }
      this.startSLInterpreter(view, selection);
    });
    this.registerDomEvent(document, "dblclick", (evt) => {
      if (!this.activated || this.pauseAllRequests) {
        return;
      }
      const view = this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
      if (!view) {
        return;
      }
      const target = evt.target;
      if (!target || !view.contentEl.contains(target)) {
        return;
      }
      if (this.parseDebounce != void 0) {
        window.clearTimeout(this.parseDebounce);
      }
      this.parseDebounce = window.setTimeout(() => {
        this.lastParsedHash = "";
        this.semaLogicUpdate();
      }, 200);
    });
    this.registerMarkdownPostProcessor((element, context) => {
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, element);
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, context);
      element.querySelectorAll("p").forEach((el) => {
        if (searchForSemaLogicCommands(el)) {
          let set = this.settings;
          context.addChild(new SemaLogicRenderedElement({ containerEl: el, set }));
        }
      });
    });
    this.addSettingTab(new SemaLogicSettingTab(this.app, this));
    await this.loadSettings();
    this.pluginEnabled = true;
    DebugLevel = this.settings.myDebugLevel;
    this.myStatus = this.addStatusBarItem();
    this.slComm = new SemaLogicPluginComm2();
    this.slComm.setSLClass(this);
    this.activateView();
    this.statusSL = true;
    await this.semaLogicReset();
    this.setViews();
    this.addRibbonIcon("book", "On/Off SemaLogic.View", () => {
      this.setViews();
      if (this.activated == false) {
        this.statusSL = true;
        if (!this.activated) {
          this.activateView();
        }
      } else {
        this.statusSL = false;
        this.deactivateView();
      }
    });
    this.addRibbonIcon("dice", "On/Off Transfer.View", () => {
      this.setViews();
      if (this.slComm != void 0) {
        if (this.slComm.activatedASP == false) {
          this.activateASPView();
        } else {
          this.deactivateASPView();
        }
      }
    });
    this.addRibbonIcon("share-2", "On/Off Knowledge.View", () => {
      this.setViews();
      if (this.slComm != void 0) {
        if (this.slComm.activatedKnowledge == false) {
          this.activateKnowledgeView();
        } else {
          this.deactivateKnowledgeView();
        }
      }
    });
    this.addCommand({
      id: "sl_create_template",
      name: "SemaLogic create template",
      callback: () => {
        createTemplateFolder(app.vault);
        createExamples(app.vault);
      }
    });
    this.attachCanvasTooltipsToAllLeaves();
    this.addCommand({
      id: "sl_create_test_canvas",
      name: "UseSemaLogic: test canvas simple",
      callback: () => {
        createTestCanvas(app.vault);
      }
    });
    this.addCommand({
      id: "sl_create_template_canvas",
      name: "UseSemaLogic: test canvas komplex",
      callback: () => {
        createTemplateCanvas(app.vault);
      }
    });
    if (this.statusSL) {
      this.semaLogicReset();
      this.slComm.slview.setNewInitial(this.settings.mySLSettings[this.settings.mySetting].myOutputFormat, true);
      this.semaLogicParse();
    }
    this.registerEditorExtension([import_view4.EditorView.updateListener.of(this.handleUpdate), slTermHider]);
  }
  async semaLogicParse() {
    if (this.pauseAllRequests) {
      return [];
    }
    this.setViews();
    slconsolelog(DebugLevMap.DebugLevel_, this.slComm.slview, "Start SemaLogicParse");
    let results = [];
    this.lastUpdate = Date.now();
    await semaLogicPing(this.settings, this.lastUpdate);
    let vAPI_URL = getHostPort(this.settings) + API_Defaults.rules_parse + "?sid=" + mygSID;
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, vAPI_URL);
    let bodytext = "";
    let activeView = this.getActiveView();
    if (activeView != void 0) {
      this.slComm.slUsedMDView = activeView;
    }
    let dialectID = "default";
    let codeblock = false;
    let newCodeblock = false;
    if (activeView != null) {
      slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, "ActiveView is not NULL");
      for (let i = 0; i < activeView.editor.lineCount(); i++) {
        slconsolelog(DebugLevMap.DebugLevel_All, this.slComm.slview, i, ";", activeView.editor.getLine(i));
        slconsolelog(DebugLevMap.DebugLevel_All, this.slComm.slview, "Substring:", activeView.editor.getLine(i).substring(0, 2));
        if (activeView.editor.getLine(i).substring(0, 3) == "```") {
          if (!codeblock) {
            codeblock = true;
            newCodeblock = true;
            slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, "Current line is Codeblock: " + i.toString(), codeblock);
          } else {
            newCodeblock = false;
          }
        }
        if (!codeblock && !newCodeblock) {
          bodytext = bodytext.concat(activeView.editor.getLine(i) + "\n");
        } else {
          switch (activeView.editor.getLine(i).substring(0, semaLogicCommand.useDialect.length)) {
            case semaLogicCommand.useDialect: {
              dialectID = activeView.editor.getLine(i).substring(semaLogicCommand.useDialect.length, activeView.editor.getLine(i).length - 1);
              dialectID = dialectID.trim();
              break;
            }
            default: {
            }
          }
        }
        if (i < activeView.editor.lineCount()) {
          if (activeView.editor.getLine(i).substring(0, 3) == "```") {
            if (codeblock && !newCodeblock) {
              codeblock = false;
            } else {
              newCodeblock = false;
            }
          }
        }
      }
    }
    bodytext = this.view_utils.cleanCommands(bodytext);
    bodytext = this.normalizeSLInterpreterTerms(bodytext);
    if (dialectID == "") {
      dialectID = "default";
    }
    const newHash = `${dialectID}|${bodytext}`;
    if (newHash == this.lastParsedHash) {
      return results;
    }
    this.lastParsedHash = newHash;
    slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "Parsingresult for SemaLogicView");
    const responseForSemaLogic = this.slComm.slview.getSemaLogicParse(this.settings, vAPI_URL, dialectID, bodytext, false);
    responseForSemaLogic.then((value) => {
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, value);
    });
    if (this.slComm.activatedASP) {
      if (Date.now() - this.slComm.slaspview.LastRequestTime >= this.settings.mySLSettings[this.settings.mySetting].myUpdateInterval) {
        this.slComm.slaspview.LastRequestTime = Date.now();
        slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, `Set-Requesttime: ${this.slComm.slaspview.LastRequestTime}`);
        this.updateTransferOutstanding = false;
        let outputFormat = RulesettypesCommands[Rstypes_ASP][1];
        const responseForASP = this.slComm.slview.getSemaLogicParse(this.settings, vAPI_URL, dialectID, bodytext, true, outputFormat);
        responseForASP.then((value) => {
          slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, value);
          const aspPromise = this.slComm.slaspview.aspParse(this.slComm, this.settings, value, this.slComm.slaspview.LastRequestTime);
          aspPromise.then((value2) => {
            if (value2 != void 0) {
              slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, value2);
            }
          });
        });
      } else {
        this.updateTransferOutstanding = true;
      }
    }
    if (this.slComm.activatedKnowledge) {
      if (Date.now() - this.knowledgeLastRequestTime >= this.settings.mySLSettings[this.settings.mySetting].myUpdateInterval) {
        this.knowledgeLastRequestTime = Date.now();
        const requestTime = this.knowledgeLastRequestTime;
        slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, `Knowledge request (sid=${mygSID}) url=${vAPI_URL}`);
        const responseForKnowledge = this.slComm.slview.getSemaLogicParse(this.settings, vAPI_URL, dialectID, bodytext, true, RulesettypesCommands[Rstypes_KnowledgeGraph][1]);
        responseForKnowledge.then((value) => {
          if (this.knowledgeLastRequestTime == requestTime) {
            this.updateKnowledgeCanvas(value);
          }
        });
      }
    }
    return results;
  }
  normalizeSLInterpreterTerms(text) {
    const re = /(.+?)\s*\((SL64|SL):([^)]+)\)/g;
    return text.replace(re, (_m, _orig, mode, rawTerm) => {
      if (mode == "SL64") {
        return this.decodeSLTerm(String(rawTerm != null ? rawTerm : ""));
      }
      let term = String(rawTerm != null ? rawTerm : "");
      term = term.replace(/\\\)/g, ")").replace(/\\\(/g, "(").replace(/\\\\/g, "\\");
      return term;
    });
  }
  encodeSLTerm(text) {
    const utf8 = encodeURIComponent(text).replace(/%([0-9A-F]{2})/g, (_m, p1) => {
      return String.fromCharCode(parseInt(p1, 16));
    });
    return btoa(utf8);
  }
  decodeSLTerm(b64) {
    try {
      const bin = atob(b64);
      const pct = Array.from(bin, (c) => "%" + c.charCodeAt(0).toString(16).padStart(2, "0")).join("");
      return decodeURIComponent(pct);
    } catch (e) {
      return "";
    }
  }
  async processCanvasResponse(raw, canvasPath, allowFiles) {
    if (!raw || raw.length == 0) {
      await this.writeCanvasFile(canvasPath, '{ "nodes": [], "edges": [] }');
      return;
    }
    try {
      const parsed = JSON.parse(raw);
      if (parsed && Array.isArray(parsed.nodes) && Array.isArray(parsed.edges)) {
        if (allowFiles && Array.isArray(parsed.files)) {
          await this.createFilesFromResponse(parsed.files);
        }
        const canvas = { nodes: parsed.nodes, edges: parsed.edges };
        await this.writeCanvasFile(canvasPath, JSON.stringify(canvas));
        return;
      }
    } catch (e) {
    }
    await this.writeCanvasFile(canvasPath, raw);
  }
  async writeCanvasFile(path, content) {
    const norm = (0, import_obsidian8.normalizePath)(path);
    const folder = norm.split("/").slice(0, -1).join("/");
    if (folder.length > 0 && this.app.vault.getAbstractFileByPath(folder) == null) {
      await this.app.vault.createFolder(folder);
    }
    let file = this.app.vault.getAbstractFileByPath(norm);
    if (file == null) {
      file = await this.app.vault.create(norm, content);
    } else {
      await this.app.vault.adapter.write(norm, content);
      await this.app.vault.modify(file, content);
    }
  }
  async createFilesFromResponse(files) {
    var _a, _b;
    for (const f of files) {
      const p = (0, import_obsidian8.normalizePath)(String((_a = f == null ? void 0 : f.path) != null ? _a : ""));
      if (!p) {
        continue;
      }
      const content = String((_b = f == null ? void 0 : f.content) != null ? _b : "");
      const folder = p.split("/").slice(0, -1).join("/");
      if (folder.length > 0 && this.app.vault.getAbstractFileByPath(folder) == null) {
        await this.app.vault.createFolder(folder);
      }
      let file = this.app.vault.getAbstractFileByPath(p);
      if (file == null) {
        await this.app.vault.create(p, content);
      } else {
        await this.app.vault.adapter.write(p, content);
        await this.app.vault.modify(file, content);
      }
    }
  }
  attachCanvasTooltips(leaf) {
    var _a, _b, _c;
    if (this.canvasTooltipObservers.has(leaf)) {
      return;
    }
    const view = leaf.view;
    const container = (_a = view == null ? void 0 : view.containerEl) != null ? _a : null;
    if (!container) {
      return;
    }
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_b = this.slComm) == null ? void 0 : _b.slview, "Attach canvas tooltips: observer start");
    const observer = new MutationObserver(() => {
      var _a2;
      slconsolelog(DebugLevMap.DebugLevel_Informative, (_a2 = this.slComm) == null ? void 0 : _a2.slview, "Canvas DOM mutation");
      this.refreshCanvasTooltips(leaf);
      this.addCanvasInfoButton(leaf);
      this.updateCanvasInfoButton(leaf);
    });
    observer.observe(container, { childList: true, subtree: true, attributes: true, attributeFilter: ["class"] });
    this.canvasTooltipObservers.set(leaf, observer);
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_c = this.slComm) == null ? void 0 : _c.slview, "Attach canvas tooltips: initial refresh");
    this.refreshCanvasTooltips(leaf);
    this.addCanvasInfoButton(leaf);
    this.updateCanvasInfoButton(leaf);
  }
  attachCanvasTooltipsToAllLeaves() {
    var _a;
    let count = 0;
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a2;
      if (leaf.view.getViewType() == "canvas") {
        count++;
        slconsolelog(DebugLevMap.DebugLevel_Informative, (_a2 = this.slComm) == null ? void 0 : _a2.slview, `Attach canvas tooltips: leaf ${count}`);
        this.attachCanvasTooltips(leaf);
      }
    });
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_a = this.slComm) == null ? void 0 : _a.slview, `Attach canvas tooltips: total ${count}`);
  }
  async refreshCanvasTooltips(leaf) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const view = leaf.view;
    const canvasFile = view == null ? void 0 : view.file;
    if (!canvasFile) {
      return;
    }
    const maps = await this.loadCanvasNodeFileMaps(canvasFile);
    if (maps.idMap.size == 0 && maps.textMap.size == 0) {
      return;
    }
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_a = this.slComm) == null ? void 0 : _a.slview, `Canvas tooltip map sizes id=${maps.idMap.size} text=${maps.textMap.size}`);
    let singleFilePath;
    if (maps.idMap.size + maps.textMap.size == 1) {
      for (const v of maps.idMap.values()) {
        singleFilePath = v;
      }
      for (const v of maps.textMap.values()) {
        singleFilePath = v;
      }
    }
    const container = (_b = view == null ? void 0 : view.containerEl) != null ? _b : null;
    if (!container) {
      return;
    }
    const nodes = Array.from(container.querySelectorAll(".canvas-node"));
    for (const el of nodes) {
      if (el.dataset.slTooltipBound == "1") {
        continue;
      }
      const id = el.getAttribute("data-node-id") || el.getAttribute("data-id") || el.dataset.nodeId || el.dataset.id;
      let filePath;
      if (id) {
        filePath = maps.idMap.get(id);
      }
      if (!filePath) {
        let nodeText = "";
        const textEl = el.querySelector(".canvas-node-content .markdown-preview-view p, .canvas-node-content textarea, .canvas-node-content");
        nodeText = (_d = (_c = textEl == null ? void 0 : textEl.textContent) == null ? void 0 : _c.trim()) != null ? _d : "";
        if (!nodeText) {
          const iframe = el.querySelector("iframe.embed-iframe");
          const doc = iframe == null ? void 0 : iframe.contentDocument;
          const p = doc == null ? void 0 : doc.querySelector("p");
          nodeText = (_f = (_e = p == null ? void 0 : p.textContent) == null ? void 0 : _e.trim()) != null ? _f : "";
        }
        if (nodeText) {
          slconsolelog(DebugLevMap.DebugLevel_Informative, (_g = this.slComm) == null ? void 0 : _g.slview, `Canvas node text="${nodeText}"`);
        }
        if (nodeText.length > 0) {
          const normalized = this.extractNodeIdText(nodeText);
          filePath = (_h = maps.textMap.get(nodeText)) != null ? _h : maps.idTextMap.get(normalized);
        }
      }
      if (!filePath && singleFilePath) {
        filePath = singleFilePath;
      }
      if (filePath) {
        slconsolelog(DebugLevMap.DebugLevel_Informative, (_i = this.slComm) == null ? void 0 : _i.slview, `Canvas tooltip file=${filePath}`);
      }
      if (!filePath) {
        continue;
      }
      const fp = filePath;
      el.dataset.slTooltipBound = "1";
      el.addEventListener("mouseenter", async (evt) => {
        const content = await this.safeReadFile(fp);
        if (content.length == 0) {
          return;
        }
        this.showCanvasTooltip(content, evt);
      });
      el.addEventListener("mouseleave", () => {
        this.hideCanvasTooltip();
      });
    }
  }
  async loadCanvasNodeFileMaps(canvasFile) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const cache = this.canvasNodeFileCache.get(canvasFile.path);
    const stat = await this.app.vault.adapter.stat(canvasFile.path);
    if (cache && stat && cache.mtime == stat.mtime) {
      return { idMap: cache.map, textMap: (_a = cache.textMap) != null ? _a : /* @__PURE__ */ new Map(), dataIdMap: (_b = cache.dataMap) != null ? _b : /* @__PURE__ */ new Map(), dataTextMap: (_c = cache.dataTextMap) != null ? _c : /* @__PURE__ */ new Map(), idTextMap: (_d = cache.idTextMap) != null ? _d : /* @__PURE__ */ new Map(), dataIdTextMap: (_e = cache.dataIdTextMap) != null ? _e : /* @__PURE__ */ new Map() };
    }
    let raw = "";
    try {
      raw = await this.app.vault.cachedRead(canvasFile);
    } catch (e) {
      return { idMap: /* @__PURE__ */ new Map(), textMap: /* @__PURE__ */ new Map(), dataIdMap: /* @__PURE__ */ new Map(), dataTextMap: /* @__PURE__ */ new Map(), idTextMap: /* @__PURE__ */ new Map(), dataIdTextMap: /* @__PURE__ */ new Map() };
    }
    let parsed;
    try {
      parsed = JSON.parse(raw);
    } catch (e) {
      return { idMap: /* @__PURE__ */ new Map(), textMap: /* @__PURE__ */ new Map(), dataIdMap: /* @__PURE__ */ new Map(), dataTextMap: /* @__PURE__ */ new Map(), idTextMap: /* @__PURE__ */ new Map(), dataIdTextMap: /* @__PURE__ */ new Map() };
    }
    const map = /* @__PURE__ */ new Map();
    const textMap = /* @__PURE__ */ new Map();
    const dataMap = /* @__PURE__ */ new Map();
    const dataTextMap = /* @__PURE__ */ new Map();
    const idTextMap = /* @__PURE__ */ new Map();
    const dataIdTextMap = /* @__PURE__ */ new Map();
    if (parsed && Array.isArray(parsed.nodes)) {
      for (const n of parsed.nodes) {
        const id = String((_f = n == null ? void 0 : n.id) != null ? _f : "");
        if (!id) {
          continue;
        }
        const meta = (_g = n == null ? void 0 : n.meta) != null ? _g : {};
        const linked = (_h = meta == null ? void 0 : meta.SL_LinkedFile) != null ? _h : n == null ? void 0 : n.SL_LinkedFile;
        const data = (_i = meta == null ? void 0 : meta.SL_DataFile) != null ? _i : n == null ? void 0 : n.SL_DataFile;
        const rawText = String((_j = n == null ? void 0 : n.text) != null ? _j : "").trim();
        const nodeIdText = this.extractNodeIdText(rawText);
        if (linked) {
          map.set(id, String(linked));
          if (rawText.length > 0 && !textMap.has(rawText)) {
            textMap.set(rawText, String(linked));
          }
          if (nodeIdText.length > 0 && !idTextMap.has(nodeIdText)) {
            idTextMap.set(nodeIdText, String(linked));
          }
        }
        if (data) {
          dataMap.set(id, String(data));
          if (rawText.length > 0 && !dataTextMap.has(rawText)) {
            dataTextMap.set(rawText, String(data));
          }
          if (nodeIdText.length > 0 && !dataIdTextMap.has(nodeIdText)) {
            dataIdTextMap.set(nodeIdText, String(data));
          }
        }
      }
    }
    if (stat) {
      this.canvasNodeFileCache.set(canvasFile.path, { mtime: stat.mtime, map, textMap, dataMap, dataTextMap, idTextMap, dataIdTextMap });
    }
    return { idMap: map, textMap, dataIdMap: dataMap, dataTextMap, idTextMap, dataIdTextMap };
  }
  async safeReadFile(path) {
    const norm = (0, import_obsidian8.normalizePath)(path);
    const file = this.app.vault.getAbstractFileByPath(norm);
    if (!file) {
      try {
        return await this.app.vault.adapter.read(norm);
      } catch (e) {
        return "";
      }
    }
    try {
      return await this.app.vault.cachedRead(file);
    } catch (e) {
      return "";
    }
  }
  showCanvasTooltip(content, evt) {
    this.hideCanvasTooltip();
    const tooltip = document.createElement("div");
    tooltip.className = "sl-node-tooltip";
    document.body.appendChild(tooltip);
    this.canvasTooltipEl = tooltip;
    try {
      import_obsidian8.MarkdownRenderer.renderMarkdown(content, tooltip, "", this);
    } catch (e) {
      tooltip.textContent = content;
    }
    const x = evt.clientX + 12;
    const y = evt.clientY + 12;
    tooltip.style.left = `${x}px`;
    tooltip.style.top = `${y}px`;
    const onDocClick = (e) => {
      const target = e.target;
      if (this.canvasTooltipEl && target && this.canvasTooltipEl.contains(target)) {
        return;
      }
      this.hideCanvasTooltip();
    };
    const onKey = (e) => {
      if (e.key === "Escape") {
        this.hideCanvasTooltip();
      }
    };
    const onWheel = () => {
      this.hideCanvasTooltip();
    };
    document.addEventListener("click", onDocClick, true);
    document.addEventListener("keydown", onKey, true);
    document.addEventListener("wheel", onWheel, true);
    this.canvasTooltipCleanup = () => {
      document.removeEventListener("click", onDocClick, true);
      document.removeEventListener("keydown", onKey, true);
      document.removeEventListener("wheel", onWheel, true);
    };
  }
  hideCanvasTooltip() {
    if (this.canvasTooltipEl) {
      this.canvasTooltipEl.remove();
      this.canvasTooltipEl = void 0;
    }
    if (this.canvasTooltipCleanup) {
      this.canvasTooltipCleanup();
      this.canvasTooltipCleanup = void 0;
    }
  }
  showInterpreterResponseModal(content) {
    this.hideInterpreterResponseModal();
    const wrapper = document.createElement("div");
    wrapper.className = "sl-interpreter-modal";
    const box = document.createElement("div");
    box.className = "sl-interpreter-modal-box";
    const header = document.createElement("div");
    header.className = "sl-interpreter-modal-header";
    header.textContent = "SL-Interpreter";
    const body = document.createElement("div");
    body.className = "sl-interpreter-modal-body";
    body.textContent = "The generative AI could not find logical expressions that were clear and unambiguous enough to translate into SemaLogic.";
    const response = document.createElement("div");
    response.className = "sl-interpreter-modal-response";
    response.textContent = content;
    const closeBtn = document.createElement("button");
    closeBtn.className = "sl-interpreter-modal-close";
    closeBtn.textContent = "Close";
    closeBtn.addEventListener("click", () => this.hideInterpreterResponseModal());
    box.appendChild(header);
    box.appendChild(body);
    box.appendChild(response);
    box.appendChild(closeBtn);
    wrapper.appendChild(box);
    document.body.appendChild(wrapper);
    this.interpreterModalEl = wrapper;
    const onKey = (e) => {
      if (e.key === "Escape") {
        this.hideInterpreterResponseModal();
      }
    };
    document.addEventListener("keydown", onKey, true);
    this.interpreterModalCleanup = () => {
      document.removeEventListener("keydown", onKey, true);
    };
  }
  hideInterpreterResponseModal() {
    if (this.interpreterModalEl) {
      this.interpreterModalEl.remove();
      this.interpreterModalEl = void 0;
    }
    if (this.interpreterModalCleanup) {
      this.interpreterModalCleanup();
      this.interpreterModalCleanup = void 0;
    }
  }
  isCanvasJsonResponse(raw) {
    try {
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed == null ? void 0 : parsed.nodes) && Array.isArray(parsed == null ? void 0 : parsed.edges);
    } catch (e) {
      return false;
    }
  }
  addCanvasInfoButton(leaf) {
    var _a, _b;
    const view = leaf.view;
    const canvasFile = view == null ? void 0 : view.file;
    if (!canvasFile) {
      return;
    }
    const container = (_a = view == null ? void 0 : view.containerEl) != null ? _a : null;
    if (!container) {
      return;
    }
    const menu = container.querySelector(".canvas-menu");
    if (!menu || menu.querySelector(".sl-node-info-btn")) {
      return;
    }
    const btn = document.createElement("button");
    btn.className = "clickable-icon sl-node-info-btn";
    btn.setAttribute("aria-label", "SL Info");
    btn.textContent = "\u24D8";
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_b = this.slComm) == null ? void 0 : _b.slview, "Canvas info button attached");
    btn.addEventListener("click", async (evt) => {
      var _a2, _b2;
      evt.preventDefault();
      evt.stopPropagation();
      if (this.canvasTooltipEl) {
        this.hideCanvasTooltip();
        return;
      }
      const maps = await this.loadCanvasNodeFileMaps(canvasFile);
      let filePath;
      let nodeText = "";
      let fallbackPath;
      const focused = this.getFocusedCanvasNode(container);
      if (focused) {
        const res = this.resolveCanvasNodeFiles(focused, maps);
        if (res.dataPath) {
          filePath = res.dataPath;
          fallbackPath = void 0;
        } else {
          filePath = void 0;
          fallbackPath = res.linkedPath;
        }
        nodeText = res.nodeText;
      }
      if (!filePath && maps.dataIdMap.size + maps.dataTextMap.size == 1) {
        for (const v of maps.dataIdMap.values()) {
          filePath = v;
        }
        for (const v of maps.dataTextMap.values()) {
          filePath = v;
        }
      }
      if (!filePath && fallbackPath) {
        filePath = fallbackPath;
      }
      if (!filePath && maps.idMap.size + maps.textMap.size == 1) {
        for (const v of maps.idMap.values()) {
          filePath = v;
        }
        for (const v of maps.textMap.values()) {
          filePath = v;
        }
      }
      let content = "";
      if (filePath) {
        slconsolelog(DebugLevMap.DebugLevel_Informative, (_a2 = this.slComm) == null ? void 0 : _a2.slview, `Canvas info button: filePath=${filePath}`);
        content = await this.safeReadFile(filePath);
        slconsolelog(DebugLevMap.DebugLevel_Informative, (_b2 = this.slComm) == null ? void 0 : _b2.slview, `Canvas info button: file content len=${content.length}`);
      }
      if (content.length == 0 && nodeText.length > 0) {
        content = nodeText;
      }
      if (content.length == 0) {
        return;
      }
      this.showCanvasTooltip(content, evt);
    });
    menu.appendChild(btn);
    this.updateCanvasInfoButton(leaf);
  }
  async updateCanvasInfoButton(leaf) {
    var _a;
    const view = leaf.view;
    const canvasFile = view == null ? void 0 : view.file;
    if (!canvasFile) {
      return;
    }
    const container = (_a = view == null ? void 0 : view.containerEl) != null ? _a : null;
    if (!container) {
      return;
    }
    const btn = container.querySelector(".sl-node-info-btn");
    if (!btn) {
      return;
    }
    const focused = this.getFocusedCanvasNode(container);
    if (!focused) {
      btn.style.display = "none";
      return;
    }
    const maps = await this.loadCanvasNodeFileMaps(canvasFile);
    const res = this.resolveCanvasNodeFiles(focused, maps);
    btn.style.display = res.dataPath ? "" : "none";
  }
  resolveCanvasNodeFiles(focused, maps) {
    var _a, _b, _c, _d;
    let dataPath;
    let linkedPath;
    let nodeText = "";
    const id = focused.getAttribute("data-node-id") || focused.getAttribute("data-id") || focused.dataset.nodeId || focused.dataset.id;
    if (id) {
      dataPath = maps.dataIdMap.get(id);
      linkedPath = maps.idMap.get(id);
    }
    if (!dataPath && !linkedPath) {
      const textEl = focused.querySelector(".canvas-node-content .markdown-preview-view h1, .canvas-node-content .markdown-preview-view h2, .canvas-node-content .markdown-preview-view h3, .canvas-node-content .markdown-preview-view h4, .canvas-node-content .markdown-preview-view h5, .canvas-node-content .markdown-preview-view h6, .canvas-node-content .markdown-preview-view p, .canvas-node-content textarea, .canvas-node-content");
      nodeText = (_b = (_a = textEl == null ? void 0 : textEl.textContent) == null ? void 0 : _a.trim()) != null ? _b : "";
      if (!nodeText) {
        const iframe = focused.querySelector("iframe.embed-iframe");
        const doc = iframe == null ? void 0 : iframe.contentDocument;
        const heading = doc == null ? void 0 : doc.querySelector("h1, h2, h3, h4, h5, h6");
        const p = doc == null ? void 0 : doc.querySelector("p");
        nodeText = ((heading == null ? void 0 : heading.textContent) || (p == null ? void 0 : p.textContent) || "").trim();
      }
      if (nodeText.length > 0) {
        const normalized = this.extractNodeIdText(nodeText);
        dataPath = (_c = maps.dataTextMap.get(nodeText)) != null ? _c : maps.dataIdTextMap.get(normalized);
        linkedPath = (_d = maps.textMap.get(nodeText)) != null ? _d : maps.idTextMap.get(normalized);
      }
    }
    return { dataPath, linkedPath, nodeText };
  }
  extractNodeIdText(raw) {
    if (!raw) {
      return "";
    }
    const match = raw.match(/NodeID:\s*([^\n\r]+)/i);
    if (match && match[1]) {
      const chunk = match[1].trim();
      const stop = chunk.split(/CONCEPT:|ERROR:|OR_MIN:|OR_MAX:/i)[0].trim();
      return stop;
    }
    return raw.split(/[\r\n]/)[0].trim();
  }
  getFocusedCanvasNode(container) {
    return container.querySelector(
      ".canvas-node.is-focused, .canvas-node.is-selected, .canvas-node.is-editing"
    );
  }
  async activateASPView() {
    if (this.slComm.slaspview == void 0) {
      this.registerView(
        ASPViewType,
        (leaf2) => new ASPView(leaf2)
      );
    }
    const leaf = this.GetAspLeaf();
    if (leaf != void 0) {
      leaf.setViewState({
        type: ASPViewType,
        active: false
      });
      await this.semaLogicReset();
      this.app.workspace.revealLeaf(leaf);
    } else {
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "ASP-Leaf not created");
    }
    this.setViews();
    this.handlePing();
    this.statusTransfer = true;
    this.semaLogicUpdate();
    this.myStatus.setText("ASP is on");
  }
  async activateKnowledgeView() {
    var _a;
    slconsolelog(DebugLevMap.DebugLevel_Current_Dev, (_a = this.slComm) == null ? void 0 : _a.slview, "Activate KnowledgeView");
    await this.openKnowledgeCanvas();
    this.setViews();
    this.handlePing();
    this.semaLogicUpdate();
    this.myStatus.setText("Knowledge is on");
  }
  async activateView() {
    if (this.slComm.slview == void 0) {
      this.registerView(
        SemaLogicViewType,
        (leaf2) => new SemaLogicView2(leaf2)
      );
    }
    const leaf = this.GetSemaLogicLeaf();
    if (leaf != void 0) {
      leaf.setViewState({
        type: SemaLogicViewType,
        active: false
      });
      await this.semaLogicReset();
      this.app.workspace.revealLeaf(leaf);
    } else {
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "SemaLogic-Leaf not created");
    }
    this.setViews();
    this.handlePing();
    this.semaLogicUpdate();
    this.pluginEnabled = true;
    this.statusSL = true;
    this.myStatus.setText("SemaLogic is on");
  }
  async deactivateASPView() {
    this.app.workspace.detachLeavesOfType(ASPViewType);
    this.slComm.activatedASP = false;
    this.statusTransfer = true;
    this.myStatus.setText("ASP is off");
  }
  async deactivateKnowledgeView() {
    this.detachKnowledgeCanvasLeaves();
    this.slComm.activatedKnowledge = false;
    this.myStatus.setText("Knowledge is off");
  }
  async deactivateView() {
    this.app.workspace.detachLeavesOfType(SemaLogicViewType);
    this.activated = false;
    this.pluginEnabled = false;
    this.statusSL = false;
    this.slComm.slview.unload();
    this.myStatus.setText("SemaLogic is off");
  }
  GetAspLeaf() {
    let found = false;
    let slv = void 0;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (!found) {
        switch (leaf.view.getViewType()) {
          case ASPViewType: {
            found = true;
            slv = leaf;
          }
        }
      }
    });
    if (!found) {
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, "Split");
      slv = this.app.workspace.getLeaf("split");
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, slv);
    }
    return slv;
  }
  GetSemaLogicLeaf() {
    let found = false;
    let slv = void 0;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (!found) {
        switch (leaf.view.getViewType()) {
          case SemaLogicViewType: {
            found = true;
            slv = leaf;
          }
        }
      }
    });
    if (!found) {
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, "Split");
      slv = this.app.workspace.getLeaf("split");
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, slv);
    }
    return slv;
  }
  async ensureKnowledgeCanvasFile(content) {
    const path = (0, import_obsidian8.normalizePath)(this.knowledgeCanvasPath);
    const folder = path.split("/").slice(0, -1).join("/");
    if (folder.length > 0 && this.app.vault.getAbstractFileByPath(folder) == null) {
      await this.app.vault.createFolder(folder);
    }
    let file = this.app.vault.getAbstractFileByPath(path);
    if (file == null) {
      file = await this.app.vault.create(path, content != null ? content : '{ "nodes": [], "edges": [] }');
    } else if (content != void 0) {
      await this.app.vault.adapter.write(path, content);
      await this.app.vault.modify(file, content);
    }
    return file;
  }
  findKnowledgeCanvasLeaf() {
    let found = void 0;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (found != void 0) {
        return;
      }
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian8.normalizePath)(file.path) == (0, import_obsidian8.normalizePath)(this.knowledgeCanvasPath)) {
          found = leaf;
        }
      }
    });
    if (found != void 0) {
      this.knowledgeLeaf = found;
    }
    return found;
  }
  detachKnowledgeCanvasLeaves() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian8.normalizePath)(file.path) == (0, import_obsidian8.normalizePath)(this.knowledgeCanvasPath)) {
          leaf.detach();
        }
      }
    });
    this.knowledgeLeaf = void 0;
  }
  async openKnowledgeCanvas() {
    const file = await this.ensureKnowledgeCanvasFile();
    let leaf = this.findKnowledgeCanvasLeaf();
    if (leaf == void 0) {
      leaf = this.app.workspace.getLeaf("split");
    }
    this.knowledgeLeaf = leaf;
    await leaf.openFile(file, { active: false });
    this.attachCanvasTooltips(leaf);
    this.slComm.activatedKnowledge = true;
  }
  async updateKnowledgeCanvas(content) {
    var _a;
    slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, `Update KnowledgeCanvas (len=${(_a = content == null ? void 0 : content.length) != null ? _a : 0})`);
    await this.processCanvasResponse(content, this.knowledgeCanvasPath, false);
    const file = await this.ensureKnowledgeCanvasFile();
    let leaf = this.knowledgeLeaf;
    if (leaf == void 0) {
      leaf = this.findKnowledgeCanvasLeaf();
    }
    if (leaf != void 0) {
      this.knowledgeLeaf = leaf;
      await leaf.openFile(file, { active: false });
      this.attachCanvasTooltips(leaf);
    }
  }
  async ensureKnowledgeEditCanvasFile(content) {
    const path = (0, import_obsidian8.normalizePath)(this.knowledgeEditCanvasPath);
    const folder = path.split("/").slice(0, -1).join("/");
    if (folder.length > 0 && this.app.vault.getAbstractFileByPath(folder) == null) {
      await this.app.vault.createFolder(folder);
    }
    let file = this.app.vault.getAbstractFileByPath(path);
    if (file == null) {
      file = await this.app.vault.create(path, content != null ? content : '{ "nodes": [], "edges": [] }');
    } else if (content != void 0) {
      await this.app.vault.adapter.write(path, content);
      await this.app.vault.modify(file, content);
    }
    return file;
  }
  findKnowledgeEditLeaf() {
    let found = void 0;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (found != void 0) {
        return;
      }
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian8.normalizePath)(file.path) == (0, import_obsidian8.normalizePath)(this.knowledgeEditCanvasPath)) {
          found = leaf;
        }
      }
    });
    if (found != void 0) {
      this.knowledgeEditLeaf = found;
    }
    return found;
  }
  detachKnowledgeEditCanvasLeaves() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian8.normalizePath)(file.path) == (0, import_obsidian8.normalizePath)(this.knowledgeEditCanvasPath)) {
          leaf.detach();
        }
      }
    });
    this.knowledgeEditLeaf = void 0;
  }
  async openKnowledgeEditCanvas() {
    const file = await this.ensureKnowledgeEditCanvasFile();
    let leaf = this.findKnowledgeEditLeaf();
    if (leaf == void 0) {
      leaf = this.app.workspace.getLeaf("split");
    }
    this.knowledgeEditLeaf = leaf;
    await leaf.openFile(file, { active: false });
    this.attachCanvasTooltips(leaf);
  }
  async ensureSemaLogicViewForRequest() {
    var _a, _b;
    if (((_a = this.slComm) == null ? void 0 : _a.slview) != void 0) {
      return true;
    }
    await this.activateView();
    return ((_b = this.slComm) == null ? void 0 : _b.slview) != void 0;
  }
  async tickKnowledgeEdit() {
    var _a, _b, _c;
    if (!this.pauseAllRequests || this.knowledgeEditSelection == void 0) {
      return;
    }
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_a = this.slComm) == null ? void 0 : _a.slview, "KnowledgeEdit tick");
    const file = await this.ensureKnowledgeEditCanvasFile();
    const content = await this.app.vault.adapter.read(file.path);
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_b = this.slComm) == null ? void 0 : _b.slview, `KnowledgeEdit canvas len=${content.length}`);
    if (content == this.knowledgeEditLastCanvas) {
      return;
    }
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_c = this.slComm) == null ? void 0 : _c.slview, "KnowledgeEdit canvas changed");
    this.knowledgeEditLastCanvas = content;
    const vAPI_URL = getHostPort(this.settings) + "/canvas/convert";
    const response = await this.requestCanvasConvert(vAPI_URL, content);
    if (response == void 0 || response.length == 0) {
      return;
    }
    const sel = this.knowledgeEditSelection;
    const editor = sel.view.editor;
    const current = editor.getRange(sel.from, sel.to);
    if (current != sel.original) {
      slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, "KnowledgeEdit: selection changed, skip replace");
      return;
    }
    editor.replaceRange(response, sel.from, sel.to);
    const fromOffset = editor.posToOffset(sel.from);
    sel.to = editor.offsetToPos(fromOffset + response.length);
    sel.original = response;
    this.pauseAllRequests = false;
    this.semaLogicUpdate();
    this.pauseAllRequests = true;
  }
  async startKnowledgeEdit(view, selection) {
    var _a;
    if (!this.pluginEnabled || selection.length == 0) {
      return;
    }
    if (!await this.ensureSemaLogicViewForRequest()) {
      return;
    }
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_a = this.slComm) == null ? void 0 : _a.slview, "Start KnowledgeEdit");
    this.pauseAllRequests = true;
    this.updateOutstanding = false;
    this.updateTransferOutstanding = false;
    this.knowledgeEditLastCanvas = "";
    const from = view.editor.getCursor("from");
    const to = view.editor.getCursor("to");
    this.knowledgeEditSelection = { view, from, to, original: selection };
    const vAPI_URL = getHostPort(this.settings) + API_Defaults.rules_parse + "?sid=" + mygSID;
    const response = await this.slComm.slview.getSemaLogicParse(this.settings, vAPI_URL, "default", selection, true, RulesettypesCommands[Rstypes_KnowledgeGraph][1]);
    await this.processCanvasResponse(response, this.knowledgeEditCanvasPath, false);
    await this.openKnowledgeEditCanvas();
    if (this.knowledgeEditInterval != void 0) {
      window.clearInterval(this.knowledgeEditInterval);
      this.knowledgeEditInterval = void 0;
    }
  }
  async stopKnowledgeEdit() {
    if (this.knowledgeEditInterval != void 0) {
      window.clearInterval(this.knowledgeEditInterval);
      this.knowledgeEditInterval = void 0;
    }
    if (this.knowledgeEditDebounce != void 0) {
      window.clearTimeout(this.knowledgeEditDebounce);
      this.knowledgeEditDebounce = void 0;
    }
    this.detachKnowledgeEditCanvasLeaves();
    const file = this.app.vault.getAbstractFileByPath((0, import_obsidian8.normalizePath)(this.knowledgeEditCanvasPath));
    if (file != void 0) {
      await this.app.vault.delete(file);
    }
    this.knowledgeEditLastCanvas = "";
    this.knowledgeEditSelection = void 0;
    this.pauseAllRequests = false;
  }
  async ensureInterpreterCanvasFile(content) {
    const path = (0, import_obsidian8.normalizePath)(this.interpreterCanvasPath);
    const folder = path.split("/").slice(0, -1).join("/");
    if (folder.length > 0 && this.app.vault.getAbstractFileByPath(folder) == null) {
      await this.app.vault.createFolder(folder);
    }
    let file = this.app.vault.getAbstractFileByPath(path);
    if (file == null) {
      file = await this.app.vault.create(path, content != null ? content : '{ "nodes": [], "edges": [] }');
    } else if (content != void 0) {
      await this.app.vault.adapter.write(path, content);
      await this.app.vault.modify(file, content);
    }
    return file;
  }
  findInterpreterLeaf() {
    let found = void 0;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (found != void 0) {
        return;
      }
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian8.normalizePath)(file.path) == (0, import_obsidian8.normalizePath)(this.interpreterCanvasPath)) {
          found = leaf;
        }
      }
    });
    if (found != void 0) {
      this.interpreterLeaf = found;
    }
    return found;
  }
  detachInterpreterCanvasLeaves() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian8.normalizePath)(file.path) == (0, import_obsidian8.normalizePath)(this.interpreterCanvasPath)) {
          leaf.detach();
        }
      }
    });
    this.interpreterLeaf = void 0;
  }
  async openInterpreterCanvas() {
    const file = await this.ensureInterpreterCanvasFile();
    let leaf = this.findInterpreterLeaf();
    if (leaf == void 0) {
      leaf = this.app.workspace.getLeaf("split");
    }
    this.interpreterLeaf = leaf;
    await leaf.openFile(file, { active: false });
    this.attachCanvasTooltips(leaf);
  }
  async tickSLInterpreter() {
    var _a;
    if (!this.pauseAllRequests || this.interpreterSelection == void 0) {
      return;
    }
    const file = await this.ensureInterpreterCanvasFile();
    const content = await this.app.vault.adapter.read(file.path);
    if (content == this.interpreterLastCanvas) {
      return;
    }
    this.interpreterLastCanvas = content;
    const vAPI_URL = getHostPort(this.settings) + "/canvas/convert";
    const response = await this.requestCanvasConvert(vAPI_URL, content);
    if (response == void 0 || response.length == 0) {
      return;
    }
    const sel = this.interpreterSelection;
    const editor = sel.view.editor;
    const current = editor.getRange(sel.from, sel.to);
    if (current != sel.lastRendered && current != sel.original) {
      slconsolelog(DebugLevMap.DebugLevel_Informative, (_a = this.slComm) == null ? void 0 : _a.slview, "SL-Interpreter: selection changed, skip replace");
      return;
    }
    const trailingMatch = sel.original.match(/\s+$/);
    const trailingSpace = trailingMatch ? trailingMatch[0] : "";
    const baseOriginal = trailingSpace.length > 0 ? sel.original.slice(0, -trailingSpace.length) : sel.original;
    let spacer = trailingSpace;
    if (spacer.length == 0) {
      const nextChar = editor.getRange(sel.to, { line: sel.to.line, ch: sel.to.ch + 1 });
      if (nextChar && !/\s/.test(nextChar)) {
        spacer = " ";
      }
    }
    const encoded = this.encodeSLTerm(response);
    const newText = `\xAB${baseOriginal}\xBB (SL64:${encoded})${spacer}`;
    editor.replaceRange(newText, sel.from, sel.to);
    const fromOffset = editor.posToOffset(sel.from);
    sel.to = editor.offsetToPos(fromOffset + newText.length);
    sel.lastRendered = newText;
    this.pauseAllRequests = false;
    this.semaLogicUpdate();
    this.pauseAllRequests = true;
  }
  async startSLInterpreter(view, selection) {
    var _a;
    if (!this.pluginEnabled || selection.length == 0) {
      return;
    }
    if (!await this.ensureSemaLogicViewForRequest()) {
      return;
    }
    this.pauseAllRequests = true;
    this.updateOutstanding = false;
    this.updateTransferOutstanding = false;
    this.interpreterLastCanvas = "";
    const from = view.editor.getCursor("from");
    const to = view.editor.getCursor("to");
    this.interpreterSelection = { view, from, to, original: selection, lastRendered: selection };
    const vAPI_URL = getHostPort(this.settings) + API_Defaults.rules_parse + "?sid=" + mygSID + "&NLP=true";
    const response = await this.slComm.slview.getSemaLogicParse(this.settings, vAPI_URL, "default", selection, true, RulesettypesCommands[Rstypes_KnowledgeGraph][1]);
    if (response && this.isCanvasJsonResponse(response)) {
      await this.processCanvasResponse(response, this.interpreterCanvasPath, false);
      await this.openInterpreterCanvas();
    } else if (response && response.trim().length > 0) {
      slconsolelog(DebugLevMap.DebugLevel_Chatty, (_a = this.slComm) == null ? void 0 : _a.slview, "SL-Interpreter response (modal)", response);
      this.showInterpreterResponseModal(response);
      this.interpreterSelection = void 0;
      this.interpreterLastCanvas = "";
      this.pauseAllRequests = false;
      return;
    } else {
      this.interpreterSelection = void 0;
      this.interpreterLastCanvas = "";
      this.pauseAllRequests = false;
      return;
    }
    if (this.interpreterInterval != void 0) {
      window.clearInterval(this.interpreterInterval);
      this.interpreterInterval = void 0;
    }
  }
  async stopSLInterpreter() {
    if (this.interpreterInterval != void 0) {
      window.clearInterval(this.interpreterInterval);
      this.interpreterInterval = void 0;
    }
    if (this.interpreterDebounce != void 0) {
      window.clearTimeout(this.interpreterDebounce);
      this.interpreterDebounce = void 0;
    }
    this.detachInterpreterCanvasLeaves();
    const file = this.app.vault.getAbstractFileByPath((0, import_obsidian8.normalizePath)(this.interpreterCanvasPath));
    if (file != void 0) {
      await this.app.vault.delete(file);
    }
    this.interpreterLastCanvas = "";
    this.interpreterSelection = void 0;
    this.pauseAllRequests = false;
  }
  async requestCanvasConvert(apiUrl, canvasJson) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    let body = "";
    try {
      let parsed;
      try {
        parsed = JSON.parse(canvasJson);
      } catch (e) {
        slconsolelog(DebugLevMap.DebugLevel_Error, (_a = this.slComm) == null ? void 0 : _a.slview, `Canvas2SL invalid JSON: ${e}`);
        return "";
      }
      body = JSON.stringify(parsed);
      const nodesCount = Array.isArray(parsed == null ? void 0 : parsed.nodes) ? parsed.nodes.length : 0;
      const edgesCount = Array.isArray(parsed == null ? void 0 : parsed.edges) ? parsed.edges.length : 0;
      slconsolelog(DebugLevMap.DebugLevel_Informative, (_b = this.slComm) == null ? void 0 : _b.slview, `Canvas2SL request len=${body.length} nodes=${nodesCount} edges=${edgesCount}`);
      const response = await (0, import_obsidian8.requestUrl)({
        url: apiUrl,
        method: "POST",
        headers: {
          "content-type": "text/plain",
          "accept": "text/plain, application/json"
        },
        body
      });
      if (response.status == 200) {
        const text = (_c = response.text) != null ? _c : "";
        slconsolelog(DebugLevMap.DebugLevel_Informative, (_d = this.slComm) == null ? void 0 : _d.slview, `Canvas2SL ok len=${text.length}`);
        if (text.trim().length > 0) {
          return text;
        }
        const jsonValue = response.json;
        if (jsonValue != void 0) {
          slconsolelog(DebugLevMap.DebugLevel_Informative, (_e = this.slComm) == null ? void 0 : _e.slview, `Canvas2SL json type=${typeof jsonValue}`);
          if (typeof jsonValue === "string") {
            return jsonValue;
          }
          return JSON.stringify(jsonValue);
        }
        return "";
      }
      slconsolelog(DebugLevMap.DebugLevel_Error, (_f = this.slComm) == null ? void 0 : _f.slview, `Canvas2SL status ${response.status}`);
      slconsolelog(DebugLevMap.DebugLevel_Error, (_g = this.slComm) == null ? void 0 : _g.slview, { url: apiUrl, headers: { "content-type": "text/plain", "accept": "text/plain, application/json" }, body });
    } catch (e) {
      const err = e;
      const status = (_i = err == null ? void 0 : err.status) != null ? _i : (_h = err == null ? void 0 : err.response) == null ? void 0 : _h.status;
      const respText = (_l = (_k = (_j = err == null ? void 0 : err.response) == null ? void 0 : _j.text) != null ? _k : err == null ? void 0 : err.text) != null ? _l : "";
      slconsolelog(DebugLevMap.DebugLevel_Error, (_m = this.slComm) == null ? void 0 : _m.slview, `Canvas2SL failed: status=${status} text=${respText}`);
      slconsolelog(DebugLevMap.DebugLevel_Error, (_n = this.slComm) == null ? void 0 : _n.slview, { url: apiUrl, headers: { "content-type": "text/plain", "accept": "text/plain, application/json" }, body });
    }
    return "";
  }
  async onunload() {
    this.app.workspace.detachLeavesOfType(SemaLogicViewType);
    this.app.workspace.detachLeavesOfType(ASPViewType);
    this.detachKnowledgeCanvasLeaves();
    this.detachKnowledgeEditCanvasLeaves();
    this.detachInterpreterCanvasLeaves();
    await this.stopKnowledgeEdit();
    await this.stopSLInterpreter();
  }
  async loadSettings() {
    this.settings = Object.assign({}, Default_profile, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.slComm.slview != void 0) {
      this.slComm.slview.setNewInitial(this.settings.mySLSettings[this.settings.mySetting].myOutputFormat, false);
    }
    this.updateOutstanding = true;
  }
  handlePing() {
    semaLogicPing(this.settings, this.lastUpdate);
  }
  semaLogicUpdate(setView) {
    this.waitingForResponse = true;
    this.UpdateProcessing = true;
    if (setView == true || setView == void 0) {
      this.setViews();
    }
    slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, "Start SemaLogicUpdate");
    this.setViews();
    let activeView = this.getActiveView();
    this.semaLogicParse();
    if (!this.updating) {
      this.updating = true;
      this.updating = false;
    }
    this.UpdateProcessing = false;
    this.waitingForResponse = false;
  }
  getSemaLogicText() {
    if (this.slComm.slview.contentEl.textContent == null) {
      return "";
    } else {
      return this.slComm.slview.getContent();
    }
  }
  async semaLogicReset() {
    let vAPI_URL_Reset = getHostPort(this.settings) + API_Defaults.reset + "?sid=" + mygSID;
    let optionsReset;
    if (this.settings.mySLSettings[this.settings.mySetting].myUseHttpsSL && this.settings.mySLSettings[this.settings.mySetting].myUserSL != "") {
      optionsReset = {
        url: vAPI_URL_Reset,
        method: "POST",
        headers: {
          "content-type": "text/plain",
          "Authorization": "Basic " + btoa(this.settings.mySLSettings[this.settings.mySetting].myUserSL + ":" + this.settings.mySLSettings[this.settings.mySetting].myPasswordSL)
        }
      };
    } else {
      optionsReset = {
        url: vAPI_URL_Reset,
        method: "POST",
        headers: {
          "content-type": "text/plain"
        }
      };
    }
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, optionsReset);
    try {
      const responseReset = await (0, import_obsidian8.requestUrl)(optionsReset);
      slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, `SemaLogic: Reset with http-status ${responseReset.status.toString()}`);
    } catch (e) {
      slconsolelog(DebugLevMap.DebugLevel_Error, this.slComm.slview, `Catcherror by reset ${vAPI_URL_Reset}`);
      slconsolelog(DebugLevMap.DebugLevel_Error, this.slComm.slview, e.toString());
    }
  }
};
