/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  DebugLevel: () => DebugLevel,
  Default_profile: () => Default_profile,
  SemaLogicPluginComm: () => SemaLogicPluginComm2,
  default: () => SemaLogicPlugin,
  mygSID: () => mygSID
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/view.ts
var import_obsidian3 = require("obsidian");

// src/const.ts
var API_Defaults = {
  http: "http://",
  https: "https://",
  Base_URL: "service.semalogic.ddns.net",
  Port: "443",
  rules_parse: "/rules/parse",
  reset: "/reset",
  Version: "/APIVersion",
  PostDialect: "/dialect/define",
  RemoveDialect: "/dialect/remove",
  GetAPI: "/APIVersion",
  SID: "12345678",
  ShowContext: true,
  useUserPasswortforHTTP: true,
  HttpUser: "User",
  HttpPassword: "Password",
  viewheader: "SVG",
  AspUrl: "ASP-Service-URL.com/",
  AspEndpoint: "/plans/count",
  useUserPasswortforHTTPSL: true,
  HttpUserSL: "User",
  HttpPasswordSL: "Password"
};
var Value_Defaults = {
  updateInterval: 500
};
var semaLogicCommand = {
  command_start: "SemaLogic(",
  command_end: ")",
  showHelp: "show help",
  showVersion: "show version",
  getDialectwTemplate: "template",
  useDialect: "use ???dialectName???",
  define: "define",
  showParse: "show as",
  showFilter: "for",
  transfer: "transfer",
  transferEndpoint: "to endpoint",
  transferParam: "with param"
};
var semaLogicHelp = [
  [semaLogicCommand.command_start + "???" + semaLogicCommand.command_end, "You can define what SemaLogic should do for you by replacing ??? with one of the following SemaLogic commands:"],
  [semaLogicCommand.command_start + semaLogicCommand.showHelp + semaLogicCommand.command_end, "Show this help information"],
  [semaLogicCommand.command_start + semaLogicCommand.showVersion + semaLogicCommand.command_end, "Show the version of the SemaLogic-Service"],
  [semaLogicCommand.command_start + semaLogicCommand.define + semaLogicCommand.command_end, "After this inlinecommand and a space line comes e.g. a table that should be interpreted by SemaLogic (table, NTable, ZTable) with optional headerinterpretation- Expected format:\n(|Symbol||Level(n+1)|\n|---|---|\n|Level(1)|Level(n)|Value|)"],
  [`${semaLogicCommand.command_start + semaLogicCommand.showParse} %1 ${semaLogicCommand.showFilter} %2 ${semaLogicCommand.command_end}`, "show as - shows an output directly to the reading view ( with %1 you have to set the output type: 1|1 {picture, syemalogic, asp} and with %2 you could filter for an symbol by symbolname)"],
  [`${semaLogicCommand.command_start + semaLogicCommand.transfer} %1 ${semaLogicCommand.transferEndpoint} %2 ${semaLogicCommand.transferParam} %3 ${semaLogicCommand.command_end}`, "transfer - shows an (currently only) asp output directly to the asp.view from SemaLogicView ( with %1 you have to set the output type: 1|1 {asp} and with %2 you could set the endpoint and wuth %3 you could set queryparameter)"]
];
var Rstypes_Semalogic = 0;
var Rstypes_Picture = 3;
var Rstypes_ASP = 6;
var Rstypes_SemanticTree = 8;
var Rstypes_KnowledgeGraph = 9;
var RulesettypesCommands = [
  ["SemaLogic", "SemaLogic"],
  ["technical", "SemaLogic"],
  ["semalogic", "SemaLogic"],
  ["Picture (SVG)", "SVG"],
  ["picture", "SVG"],
  ["SVG", "SVG"],
  ["ASP", "ASP.json"],
  ["asp", "ASP.json"],
  ["SemanticTree", "SemanticTree"],
  ["KnwoledgeGraph", "KnowledgeGraph"]
];
var DebugLevelNames = [
  "DebugLevel_Off",
  "DebugLevel_Error",
  "DebugLevel_Current_Dev",
  "DebugLevel_Important",
  "DebugLevel_Informative",
  "DebugLevel_Chatty",
  "DebugLevel_All"
];
var DebugLevMap = {
  "DebugLevel_Off": 0,
  "DebugLevel_Error": 1,
  "DebugLevel_Current_Dev": 2,
  "DebugLevel_Important": 3,
  "DebugLevel_Informative": 4,
  "DebugLevel_Chatty": 5,
  "DebugLevel_All": 6
};
var slTexts = {
  "HeaderSL": "SemaLogic.View",
  "HeaderTV": "Transfer.View",
  "HeaderKnowledge": "Knowledge.View"
};
var slTemplate = {
  "PathCommands": "Templates/SemaLogic/Commands",
  "PathSymTokenComparison": "Templates/SemaLogic/SymToken/Comparison",
  "PathSymTokenElements": "Templates/SemaLogic/SymToken/Elements",
  "PathSymTokenFunc": "Templates/SemaLogic/SymToken/FuncToken",
  "PathSymTokenMath": "Templates/SemaLogic/SymToken/Math",
  "PathSymTokenRefToken": "Templates/SemaLogic/SymToken/RefToken",
  "PathSymTokenTerms": "Templates/SemaLogic/SymToken/TermsAndRules",
  "PathExamplesBasic": "Templates/SemaLogic/Examples/Basic"
};

// src/utils.ts
var import_obsidian = require("obsidian");
var import_obsidian2 = require("obsidian");
var searchForSemaLogicCommands = (el) => {
  for (let i = 0; i < el.childNodes.length; i++) {
    const child = el.childNodes[i];
    if (isSemaLogicCommand(child)) {
      return true;
    }
  }
  return false;
};
var isSemaLogicCommand = (n) => {
  var _a;
  return n.nodeType === Node.TEXT_NODE && Boolean((_a = n.textContent) == null ? void 0 : _a.startsWith(semaLogicCommand.command_start));
};
var replaceWithEmptyNode = (containerEl) => {
  const results = [];
  return results;
};
async function replaceWithCommandNode(containerEl, settings) {
  var _a, _b;
  let results = [];
  let found = false;
  let semaLogicCom = (_b = containerEl.textContent) == null ? void 0 : _b.substring(semaLogicCommand.command_start.length, (_a = containerEl.textContent) == null ? void 0 : _a.indexOf(semaLogicCommand.command_end)).toLowerCase();
  if (!found && (semaLogicCom == null ? void 0 : semaLogicCom.toString().substring(0, semaLogicCommand.showHelp.length)) == semaLogicCommand.showHelp) {
    results = await showHelp();
    found = true;
  }
  if (!found && (semaLogicCom == null ? void 0 : semaLogicCom.toString().substring(0, semaLogicCommand.showVersion.length)) == semaLogicCommand.showVersion) {
    results = await showVersion(settings);
    found = true;
  }
  if (!found && (semaLogicCom == null ? void 0 : semaLogicCom.toString().substring(0, semaLogicCommand.showParse.length)) == semaLogicCommand.showParse) {
    let rulesettype = "";
    let filter = "";
    for (let rule in RulesettypesCommands) {
      if (semaLogicCom.contains(RulesettypesCommands[rule][0])) {
        rulesettype = RulesettypesCommands[rule][1];
        const findfor = semaLogicCom.indexOf(semaLogicCommand.showFilter);
        if (findfor > 0) {
          filter = semaLogicCom.substring(findfor + semaLogicCommand.showFilter.length);
          filter = filter.trim();
        }
        found = true;
        break;
      }
    }
    if (!found) {
      results = await showHelp();
      found = true;
    }
    if (rulesettype != "") {
      results = await showParseWithFilter(filter, rulesettype, settings);
    }
    found = true;
  }
  if (!found) {
    results = replaceWithEmptyNode(containerEl);
  }
  return results;
}
var SemaLogicRenderedElement = class extends import_obsidian.MarkdownRenderChild {
  constructor({ containerEl, set }) {
    super(containerEl);
    this.mysettings = set;
  }
  async onload() {
    this.containerEl.setChildrenInPlace(
      await replaceWithCommandNode(this.containerEl, this.mysettings)
    );
  }
};
async function showHelp() {
  let results = [];
  let buildcontainerEl;
  slconsolelog(DebugLevMap.DebugLevel_Informative, void 0, semaLogicCommand.showHelp);
  buildcontainerEl = createEl("table");
  let body = buildcontainerEl.createEl("body");
  let row = body.createEl("tr");
  row.createEl("td", { text: "SemaLogic-Commands-Help" });
  row.createEl("td", { text: "Description" });
  for (let i = 0; i < semaLogicHelp.length; i++) {
    const row2 = body.createEl("tr");
    row2.createEl("td", { text: semaLogicHelp[i][0] });
    row2.createEl("td", { text: semaLogicHelp[i][1] });
  }
  results.push(buildcontainerEl);
  return results;
}
async function showVersion(settings) {
  let results = [];
  let buildcontainerEl;
  let versiontext = "";
  slconsolelog(DebugLevMap.DebugLevel_Informative, void 0, semaLogicCommand.showVersion);
  const version = await semaLogicGetVersion(settings).then(function(resultBuffer) {
    versiontext = resultBuffer;
  }).catch(
    function(resultBuffer) {
      versiontext = resultBuffer;
    }
  );
  slconsolelog(DebugLevMap.DebugLevel_High, void 0, `JSON-Text in Processor:${versiontext}`);
  buildcontainerEl = createEl("table");
  const table = buildcontainerEl.createEl("table");
  const body = buildcontainerEl.createEl("body");
  const row = body.createEl("tr");
  row.createEl("td", { text: versiontext });
  results.push(buildcontainerEl);
  return results;
}
function sethttps(https) {
  let str;
  if (https) {
    str = API_Defaults.https;
  } else {
    str = API_Defaults.http;
  }
  return str;
}
function getHostPort(settings) {
  let adress = sethttps(settings.mySLSettings[settings.mySetting].myUseHttpsSL);
  adress = adress + settings.mySLSettings[settings.mySetting].myBaseURL;
  if (settings.mySLSettings[settings.mySetting].myPort != "") {
    adress = adress + ":" + settings.mySLSettings[settings.mySetting].myPort;
  }
  slconsolelog(DebugLevMap.DebugLevel_High, void 0, "getting SemaLogic-Adress: " + adress);
  return adress;
}
function getHostAspPort(settings, parsedCommands) {
  let adress;
  if (parsedCommands.outputformat == RulesettypesCommands[Rstypes_ASP][1]) {
    adress = sethttps(settings.mySLSettings[settings.mySetting].myUseHttps);
    adress = adress + settings.mySLSettings[settings.mySetting].myAspUrl;
    if (parsedCommands.endpoint != void 0) {
      if (parsedCommands.endpoint.indexOf("http") >= 0) {
        adress = parsedCommands.endpoint;
      } else {
        adress = adress + "/" + parsedCommands.endpoint;
      }
    }
  } else {
    adress = parsedCommands.endpoint;
  }
  if (parsedCommands.param != void 0 && parsedCommands.param != "") {
    adress = adress + "?" + parsedCommands.param;
  }
  slconsolelog(DebugLevMap.DebugLevel_High, void 0, "getting asp-Adress: " + adress);
  return adress;
}
async function semaLogicGetVersion(settings) {
  slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Start semaLogicGetVersion");
  const myVersion = '{"version":"0","versiontext":"Text"}';
  let myJson = JSON.parse(myVersion);
  let jsonVersion = "";
  let vAPI_URL_Version = getHostPort(settings) + API_Defaults.Version;
  slconsolelog(DebugLevMap.DebugLevel_Important, void 0, vAPI_URL_Version);
  let options;
  if (settings.mySLSettings[settings.mySetting].myUseHttpsSL && settings.mySLSettings[settings.mySetting].myUserSL != "") {
    options = {
      url: vAPI_URL_Version,
      method: "GET",
      headers: {
        "content-type": "application/json",
        "Authorization": "Basic " + btoa(settings.mySLSettings[settings.mySetting].myUserSL + ":" + settings.mySLSettings[settings.mySetting].myPasswordSL)
      }
    };
  } else {
    options = {
      url: vAPI_URL_Version,
      method: "GET"
    };
  }
  let response;
  try {
    response = await (0, import_obsidian2.requestUrl)(options);
    myJson = JSON.parse(response.text);
    slconsolelog(DebugLevMap.DebugLevel_All, void 0, myJson.version);
    jsonVersion = myJson.version;
    slconsolelog(DebugLevMap.DebugLevel_All, void 0, `JSON-Text in Request:${jsonVersion}`);
    return jsonVersion;
  } catch (e) {
    slconsolelog(DebugLevMap.DebugLevel_Error, void 0, "Error: Catch of APIVersion" + e.toString());
    throw new Error();
  }
}
async function semaLogicPing(settings, lastUpdate) {
  let starttime = Date.now();
  slconsolelog(DebugLevMap.DebugLevel_Informative, void 0, "GetVersionPing at ", Date.now(), "  for ", getHostPort(settings));
  await semaLogicGetVersion(settings).then(function(resultBuffer) {
    slconsolelog(DebugLevMap.DebugLevel_Informative, void 0, "SemaLogic GetVersionPing started at:", starttime, " Endtime: ", Date.now());
  }).catch(
    function(e) {
      if (starttime < lastUpdate) {
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, `There is no connection to SemaLogicService APIVersion`);
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, getHostPort(settings));
        app.workspace.iterateAllLeaves((leaf) => {
          let slView = leaf.view.getViewType();
          if (slView == SemaLogicViewType) {
            const container = leaf.view.containerEl.children[1];
            container.empty();
            container.createEl("h3", { text: "SemaLogic_Error" });
            container.createEl("b", { text: "There is no connection to SemaLogicService -> APIVersion" });
            container.createEl("b", { text: getHostPort(settings) });
            return false;
          }
        });
      } else {
        slconsolelog(DebugLevMap.DebugLevel_High, void 0, "SemaLogic GetVersionPing failed and not used started:", starttime, " Endtime: ", Date.now());
      }
    }
  );
  return true;
}
async function showParseWithFilter(filter, rulessettype, settings) {
  let results = [];
  let buildcontainerEl;
  let vAPI_URL = getHostPort(settings) + API_Defaults.rules_parse + "?sid=" + mygSID;
  slconsolelog(DebugLevMap.DebugLevel_Important, void 0, vAPI_URL);
  let bodytext = "";
  let activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
  if (activeView == void 0) {
    slconsolelog(DebugLevMap.DebugLevel_High, void 0, "Do not find an active view");
    return results;
  }
  let dialectID = "default";
  let codeblock = false;
  let newCodeblock = false;
  if (activeView != null) {
    for (let i = 0; i < activeView.editor.lineCount(); i++) {
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, i, ";", activeView.editor.getLine(i));
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, "Substring:", activeView.editor.getLine(i).substring(0, 2));
      if (activeView.editor.getLine(i).substring(0, 3) == "```") {
        if (!codeblock) {
          codeblock = true;
          newCodeblock = true;
        } else {
          newCodeblock = false;
        }
      }
      slconsolelog(DebugLevMap.DebugLevel_Informative, void 0, "Current line is Codeblock", codeblock);
      if (!codeblock && !newCodeblock) {
        switch (activeView.editor.getLine(i)) {
          default:
            bodytext = bodytext.concat(activeView.editor.getLine(i) + "\n");
        }
      } else {
        switch (activeView.editor.getLine(i).substring(0, semaLogicCommand.useDialect.length)) {
          case semaLogicCommand.useDialect: {
            dialectID = activeView.editor.getLine(i).substring(semaLogicCommand.useDialect.length, activeView.editor.getLine(i).length - 1);
            dialectID = dialectID.trim();
            break;
          }
          default: {
          }
        }
      }
      if (i < activeView.editor.lineCount()) {
        if (activeView.editor.getLine(i).substring(0, 3) == "```") {
          if (codeblock && !newCodeblock) {
            codeblock = false;
          } else {
            newCodeblock = false;
          }
        }
      }
    }
  }
  if (bodytext == "") {
    bodytext = "";
  }
  if (dialectID == "") {
    dialectID = "default";
  }
  let result = "";
  let optionsParse;
  if (filter != "") {
    let jsonwoFilter = {
      "text": [
        {
          "textID": "fly",
          "dialectID": dialectID,
          "rules": bodytext
        }
      ],
      "filter": {
        "dialectID": "default",
        "symbols": [
          {
            "symbol": filter
          }
        ]
      },
      "persistency": false,
      "rulesettype": rulessettype
    };
    optionsParse = {
      url: vAPI_URL,
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify(jsonwoFilter)
    };
  } else {
    let jsontestwthFilter = {
      "text": [
        {
          "textID": "fly",
          "dialectID": dialectID,
          "rules": bodytext
        }
      ],
      "filter": {},
      "persistency": false,
      "rulesettype": rulessettype
    };
    optionsParse = {
      url: vAPI_URL,
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify(jsontestwthFilter)
    };
  }
  let res;
  slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, `Context: ${dialectID}, Bodytext: ${bodytext}`);
  slconsolelog(DebugLevMap.DebugLevel_Important, void 0, optionsParse);
  try {
    const responseParse = await (0, import_obsidian2.requestUrl)(optionsParse);
    const remJson = responseParse.text;
    slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "SemaLogic: Parse with http-status " + responseParse.status.toString());
    if (responseParse.status == 200) {
      let resulthttp = responseParse.text;
      const fragment = new Range().createContextualFragment(resulthttp);
      buildcontainerEl = createEl("p");
      buildcontainerEl.appendChild(fragment);
      results.push(buildcontainerEl);
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, `Parseresult:${resulthttp}`);
      return results;
    }
  } catch (e) {
    slconsolelog(DebugLevMap.DebugLevel_Error, void 0, `Catcherror of removing context ${vAPI_URL}`);
    slconsolelog(DebugLevMap.DebugLevel_Error, void 0, e.toString());
    throw e;
  }
  return results;
}
function slconsolelog(DebugValue, slview, message, ...optionalParams) {
  if (DebugLevel >= DebugValue) {
    if (slview != void 0) {
      if (slview.getViewType() == SemaLogicViewType) {
        if (slview.getDebugInline() == true) {
          let logMessages = JSON.stringify(message);
          slview.appendDebugContent(logMessages);
        } else {
          console.log(message, ...optionalParams);
        }
      }
    } else {
      console.log(message, ...optionalParams);
    }
  }
}

// src/view_utils.ts
var ViewUtils = class {
  getContent(contentEl, outPutFormat) {
    let content;
    if (contentEl.textContent == null) {
      content = "";
    } else {
      content = contentEl.textContent;
    }
    content = this.cleanContent(content, outPutFormat);
    content = this.cleanCommands(content);
    return content;
  }
  cleanContent(content, outPutFormat) {
    if (outPutFormat == RulesettypesCommands[Rstypes_ASP][1]) {
      const firstJSONBracket = content.indexOf("{");
      content = content.substring(firstJSONBracket, content.length);
    }
    if (outPutFormat == RulesettypesCommands[Rstypes_Semalogic][1]) {
      const headerString = "Semalogic Output";
      const firstheaderString = content.indexOf(headerString);
      content = content.substring(firstheaderString + headerString.length, content.length);
    }
    return content;
  }
  cleanCommands(content) {
    let contentCleaned = [];
    let contentArray = content.split("\n");
    contentArray.forEach((element) => {
      let row = element.trim();
      row = row.toLowerCase();
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "Row before:" + row);
      row = row.replaceAll(" ", "");
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "Row after:" + row);
      if (row.indexOf(semaLogicCommand.command_start.toLowerCase()) != 0) {
        contentCleaned.push(element);
      } else {
        slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "Index Define:" + row.indexOf(semaLogicCommand.define).toString());
        slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "Length Start:" + semaLogicCommand.command_start.length.toString());
        if (row.indexOf(semaLogicCommand.define) == semaLogicCommand.command_start.length) {
          contentCleaned.push(element);
        }
      }
    });
    content = "";
    contentCleaned.forEach((element) => {
      content = content + element + "\n";
    });
    return content;
  }
};

// src/view.ts
var SemaLogicViewType = "SemaLogicService";
var SemaLogicView2 = class extends import_obsidian3.ItemView {
  constructor(leaf) {
    super(leaf);
    this.scaleRatio = 100;
    this.view_utils = new ViewUtils();
    this.debugInline = false;
    this.debugContent = [];
  }
  getOutPutFormat() {
    return this.dropdownButton.getValue();
  }
  getDebugInline() {
    return this.debugInline;
  }
  getContent() {
    return this.view_utils.getContent(this.contentEl, this.getOutPutFormat());
  }
  appendDebugContent(text) {
    this.debugContent.push(text);
  }
  copyToCb() {
    const blobcontentText = (cont) => `${cont}`;
    let data = new ClipboardItem({
      "text/plain": new Blob([blobcontentText(this.currResult)], {
        type: "text/plain"
      })
    });
    navigator.clipboard.write([data]).then(() => {
      alert("successfully copied");
    }).catch(() => {
      alert("something went wrong");
    });
  }
  setComm(comm) {
    if (this.slComm != comm) {
      this.slComm = comm;
      this.setNewInitial(this.slComm.slPlugin.settings.mySLSettings[this.slComm.slPlugin.settings.mySetting].myOutputFormat, false);
    }
  }
  getViewType() {
    return SemaLogicViewType;
  }
  getDisplayText() {
    return SemaLogicViewType;
  }
  onload() {
    this.navigation = true;
    this.contentEl.contentEditable = "true";
    this.debugInline == false;
  }
  getDebugButtonText() {
    if (this.debugInline == true) {
      return "InlineDebug is on";
    } else {
      return "InlineDebug is off";
    }
  }
  createDropDownButtonForOutPutFormat(container, dropDownValue) {
    this.dropdownButton = new import_obsidian3.DropdownComponent(container).addOption(RulesettypesCommands[Rstypes_Semalogic][1], RulesettypesCommands[Rstypes_Semalogic][0]).addOption(RulesettypesCommands[Rstypes_ASP][1], RulesettypesCommands[Rstypes_ASP][0]).addOption(RulesettypesCommands[Rstypes_Picture][1], RulesettypesCommands[Rstypes_Picture][0]).addOption(RulesettypesCommands[Rstypes_SemanticTree][1], RulesettypesCommands[Rstypes_SemanticTree][0]).addOption(RulesettypesCommands[Rstypes_KnowledgeGraph][1], RulesettypesCommands[Rstypes_KnowledgeGraph][0]).setValue(dropDownValue).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, "Set ViewOutputFormat: " + value);
      this.slComm.slPlugin.updateOutstanding = true;
      dropDownValue = value;
      this.dropdownButton.setValue(value);
      this.updateScaleControls(value);
      if (value == RulesettypesCommands[Rstypes_KnowledgeGraph][1]) {
        await this.slComm.slPlugin.activateKnowledgeView();
      }
      const responseForView = this.getSemaLogicParse(this.slComm.slPlugin.settings, this.apiURL, this.dialectID, this.bodytext, false, value);
      if (value == RulesettypesCommands[Rstypes_KnowledgeGraph][1]) {
        responseForView.then((result) => {
          this.slComm.slPlugin.updateKnowledgeCanvas(result);
        });
      }
    });
    return container;
  }
  createCopyToClipboardButton(container) {
    this.copyButton = new import_obsidian3.ButtonComponent(container).setButtonText("Copy to Clipboard").onClick((mouse_event) => {
      this.copyToCb();
    });
    return container;
  }
  createDebugButton(container) {
    if (DebugLevel != DebugLevMap.DebugLevel_Off) {
      this.debugButton = new import_obsidian3.ButtonComponent(container).setButtonText(this.getDebugButtonText()).onClick((mouse_event) => {
        if (this.debugInline == true) {
          this.debugInline = false;
          this.debugContent = [];
        } else {
          this.debugInline = true;
        }
        if (this.slComm.slview != void 0) {
          slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, "Set InlineDebugging: " + this.debugInline);
        }
        this.updateView();
      });
    }
    return container;
  }
  createScaleButtons(container) {
    this.zoomIn = new import_obsidian3.ButtonComponent(container).setButtonText("-").onClick((mouse_event) => {
      this.scaleRatio = this.scaleRatio / 2;
      if (this.zoomRatio != null) {
        this.zoomRatio.setButtonText(String(this.scaleRatio));
      }
      slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, "Set ScaleRatio to: " + this.scaleRatio);
      this.updateView();
    });
    this.zoomRatio = new import_obsidian3.ButtonComponent(container).setButtonText(String(this.scaleRatio)).onClick((mouse_event) => {
      slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, "ScaleRatio := " + this.scaleRatio);
    });
    this.zoomOut = new import_obsidian3.ButtonComponent(container).setButtonText("+").onClick((mouse_event) => {
      this.scaleRatio = this.scaleRatio * 2;
      this.zoomRatio.setButtonText(String(this.scaleRatio));
      slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, "Set ScaleRatio to: " + this.scaleRatio);
      this.updateView();
    });
    return container;
  }
  checkContainerContent() {
    var _a;
    if (this.containerEl.children != void 0) {
      if (((_a = this.containerEl.children[1].textContent) == null ? void 0 : _a.substring(0, slTexts["HeaderSL"].length)) == slTexts["HeaderSL"]) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
  deleteContainerContent() {
    if (this.containerEl.children != void 0) {
      for (let i = 0; i < this.containerEl.children.length; i++) {
        if (this.containerEl.children[i].nodeName == "p") {
          while (this.containerEl.children[i] != void 0) {
            this.containerEl.children[i].empty;
          }
        }
      }
    }
  }
  updateScaleControls(outputFormat) {
    if (this.scaleControlsEl == void 0) {
      this.scaleControlsEl = this.controlsEl.createEl("span");
      this.errorEl = this.contentEl.createEl("div", { cls: "semalogic-error" });
    }
    this.scaleControlsEl.empty();
    if (outputFormat == RulesettypesCommands[Rstypes_Picture][1]) {
      this.createScaleButtons(this.scaleControlsEl);
    }
  }
  setNewInitial(dropDownValue, now) {
    if (!this.checkContainerContent() || now || this.headerEl == void 0) {
      this.contentEl.empty();
      this.headerEl = this.contentEl.createEl("h4", { text: slTexts["HeaderSL"] });
      this.controlsEl = this.contentEl.createEl("div");
      this.scaleControlsEl = this.controlsEl.createEl("span");
      this.errorEl = this.contentEl.createEl("div", { cls: "semalogic-error" });
      this.resultEl = this.contentEl.createEl("div");
      this.createDropDownButtonForOutPutFormat(this.controlsEl, dropDownValue);
      this.createCopyToClipboardButton(this.controlsEl);
      this.createDebugButton(this.controlsEl);
      this.updateScaleControls(dropDownValue);
    } else {
      this.deleteContainerContent();
    }
  }
  async onOpen() {
    this.setNewInitial(RulesettypesCommands[Rstypes_Semalogic][1], false);
  }
  async onClose() {
  }
  showError(fragment) {
    if (this.errorEl == void 0) {
      this.errorEl = this.contentEl.createEl("div", { cls: "semalogic-error" });
    }
    this.errorEl.empty();
    this.errorEl.appendChild(fragment);
  }
  onunload() {
    if (this.slComm.slPlugin != void 0) {
      this.slComm.slPlugin.activated = false;
      this.slComm.slPlugin.myStatus.setText("SemaLogic is off");
    }
  }
  createSemaLogicRequestBody(dialectID, bodytext, outPutFormat) {
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, "Context: " + dialectID + " Bodytext: " + bodytext);
    let semaLogicJsonRequestBody = {
      "text": [
        {
          "textID": "ParsingOnTheFly",
          "dialectID": dialectID,
          "rules": bodytext
        }
      ],
      "filter": {},
      "persistency": false,
      "rulesettype": outPutFormat
    };
    return semaLogicJsonRequestBody;
  }
  createSemaLogicRequest(settings, vAPI_URL, semaLogicJsonRequestBody) {
    let request = {
      url: vAPI_URL,
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify(semaLogicJsonRequestBody)
    };
    if (settings.mySLSettings[settings.mySetting].myUseHttpsSL && settings.mySLSettings[settings.mySetting].myUserSL != "") {
      request = {
        url: vAPI_URL,
        method: "POST",
        headers: {
          "content-type": "application/json",
          "Authorization": "Basic " + btoa(settings.mySLSettings[settings.mySetting].myUserSL + ":" + settings.mySLSettings[settings.mySetting].myPasswordSL)
        },
        body: JSON.stringify(semaLogicJsonRequestBody)
      };
    }
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, "Parsingsstring");
    slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, semaLogicJsonRequestBody);
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, request);
    return request;
  }
  getRequestEmbed(content) {
    if (this.getOutPutFormat() == RulesettypesCommands[Rstypes_Picture][1]) {
      let viewBoxString;
      const beginVB = content.indexOf("viewBox");
      if (beginVB > 0) {
        const endVB = content.indexOf('"', content.indexOf('"', beginVB) + 1);
        viewBoxString = content.substring(beginVB, endVB + 1);
      } else {
        viewBoxString = 'viewBox = "0 0 16 9"';
      }
      content = content.replace("<body>", "");
      content = content.replace("</body>", "");
      let header;
      header = "<svg  " + viewBoxString + ' width = "' + String(this.scaleRatio) + '%" xmlns = "http://www.w3.org/2000/svg" >\n';
      header = header + content;
      header = header + "</svg>";
      return header;
    } else {
      return content;
    }
  }
  getCurrResult() {
    return this.getRequestEmbed(this.currResult);
  }
  getCurrHTML() {
    if (this.resultEl == void 0) {
      this.resultEl = this.contentEl.createEl("div");
    }
    let responseContent = this.resultEl.createEl("div");
    if (this.debugInline == true) {
      this.debugContent.forEach((value) => {
        const textline = responseContent.createEl("span", { text: value + "\n", cls: "debuginline" });
      });
    } else {
      if (this.getOutPutFormat() == RulesettypesCommands[Rstypes_ASP][1]) {
        let resulttextarray = this.getCurrResult().split("\n");
        resulttextarray.forEach((value) => {
          const textline = responseContent.createEl("span", { text: value + "\n", cls: "debuginline" });
        });
      } else {
        responseContent.createEl("p", { text: " " });
        responseContent.insertAdjacentHTML("afterend", this.getCurrResult());
      }
    }
  }
  updateView() {
    if (this.headerEl == void 0 || this.controlsEl == void 0 || this.resultEl == void 0) {
      this.setNewInitial(this.getOutPutFormat(), false);
    }
    this.updateScaleControls(this.getOutPutFormat());
    if (this.errorEl != void 0) {
      this.errorEl.empty();
    }
    if (this.resultEl != void 0) {
      this.resultEl.empty();
    }
    this.getCurrHTML();
  }
  async getSemaLogicParse(settings, vAPI_URL, dialectID, bodytext, parseOnTheFly, parsingFormat) {
    this.bodytext = bodytext;
    this.apiURL = vAPI_URL;
    this.dialectID = dialectID;
    let outPutFormat;
    let resulthttp;
    if (parsingFormat !== void 0) {
      outPutFormat = parsingFormat;
    } else {
      outPutFormat = this.getOutPutFormat();
    }
    let semaLogicJsonRequestBody = this.createSemaLogicRequestBody(dialectID, bodytext, outPutFormat);
    let semaLogicRequest = this.createSemaLogicRequest(settings, vAPI_URL, semaLogicJsonRequestBody);
    try {
      const response = await (0, import_obsidian3.requestUrl)(semaLogicRequest);
      slconsolelog(DebugLevMap.DebugLevel_High, this.slComm.slview, "SemaLogic: Parse with http-status " + response.status.toString());
      if (response.status == 200) {
        resulthttp = response.text;
        slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, `Parseresult:${resulthttp}`);
        if (this.debugInline == false && parseOnTheFly == false) {
          this.currResult = resulthttp;
        }
        if (!parseOnTheFly) {
          this.updateView();
        }
      }
      if (this.slComm.slaspview != void 0) {
      }
      return new Promise((resolve) => {
        resolve(resulthttp);
      });
    } catch (e) {
      slconsolelog(DebugLevMap.DebugLevel_Error, this.slComm.slview, `Request failed: ${semaLogicRequest.url}`);
      slconsolelog(DebugLevMap.DebugLevel_High, this.slComm.slview, `Catcherror of removing context ${vAPI_URL}`);
      slconsolelog(DebugLevMap.DebugLevel_High, this.slComm.slview, e.toString());
      let text = new DocumentFragment();
      text.createEl("p");
      let textfragment = new Range().createContextualFragment(e.toString());
      text.appendChild(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment("See for information about the error-code of http: https://de.wikipedia.org/wiki/HTTP-Statuscode ");
      text.append(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment(semaLogicRequest.url);
      text.append(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment(String(semaLogicRequest.body));
      text.append(textfragment);
      this.showError(text);
      throw e;
    }
  }
};

// src/view_asp.ts
var import_obsidian4 = require("obsidian");
var ASPViewType = "TransferService";
var ASPView = class extends import_obsidian4.ItemView {
  constructor(leaf) {
    super(leaf);
    this.LastRequestTime = 0;
    this.navigation = true;
    this.setNewASPInitial(true);
  }
  setComm(comm) {
    this.slComm = comm;
    this.setNewASPInitial(false);
  }
  getViewType() {
    return ASPViewType;
  }
  getDisplayText() {
    return ASPViewType;
  }
  onload() {
    this.navigation = true;
    this.contentEl.contentEditable = "true";
  }
  checkASPContainerContent() {
    var _a;
    if (this.containerEl.children != void 0) {
      if (((_a = this.containerEl.children[1].textContent) == null ? void 0 : _a.substring(0, slTexts["HeaderTV"].length)) == slTexts["HeaderTV"]) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
  deleteASPContainerContent() {
    if (this.containerEl.children != void 0) {
      for (let i = 0; i < this.containerEl.children.length; i++) {
        if (this.containerEl.children[i].nodeName == "p") {
          while (this.containerEl.children[i] != void 0) {
            this.containerEl.children[i].empty;
          }
        }
      }
    }
  }
  setNewASPInitial(now) {
    let container = this.contentEl;
    if (now || !this.checkASPContainerContent()) {
      container.empty();
      container.createEl("h4", { text: slTexts["HeaderTV"] });
      container.createEl("p");
    } else {
    }
  }
  async onOpen() {
  }
  async onClose() {
  }
  showError(fragment) {
    this.contentEl.appendChild(fragment);
  }
  onunload() {
    if (this.slComm != void 0) {
      this.slComm.slPlugin.activated = false;
      this.slComm.slPlugin.myStatus.setText("Transfer is off");
    }
  }
  createRequest(comm, settings, apiUrl, method, contentType, withBasicAuth, body) {
    let request;
    let myHeader = {};
    contentType = contentType.toLowerCase();
    method = method.toUpperCase();
    switch (contentType.toLowerCase()) {
      case "json": {
        myHeader["Content-Type"] = "application/json";
        break;
      }
      case "asp": {
        myHeader["Content-Type"] = "application/json";
        break;
      }
      case "asp.json": {
        myHeader["Content-Type"] = "application/json";
        break;
      }
      case "text": {
        myHeader["Content-Type"] = "text/plain";
        break;
      }
      default: {
        myHeader["Content-Type"] = contentType;
        break;
      }
    }
    if (withBasicAuth) {
      myHeader["Authorization"] = "Basic " + btoa(settings.mySLSettings[settings.mySetting].myUser + ":" + settings.mySLSettings[settings.mySetting].myPassword);
    }
    request = {
      url: apiUrl,
      method,
      headers: myHeader,
      body
    };
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, request);
    return request;
  }
  getASPCommands(slComm, settings) {
    let parseCommands;
    parseCommands = {
      commands: [{
        outputformat: "ASP.json",
        endpoint: settings.mySLSettings[settings.mySetting].myAspEndpoint,
        param: ""
      }]
    };
    let parseInitial = true;
    if (slComm.slview != null) {
      const editortext = slComm.slUsedMDView.editor.getRange({ line: 0, ch: 0 }, { line: slComm.slUsedMDView.editor.lastLine() + 1, ch: slComm.slUsedMDView.editor.lastLine.length });
      const rows = editortext.split("\n").filter((row) => row.length > 0);
      let myStrResult;
      let transferString;
      let endpointString = "";
      let paramString;
      rows.forEach((row) => {
        if (row.substring(0, semaLogicCommand.command_start.length) == semaLogicCommand.command_start) {
          const transfer = row.indexOf(semaLogicCommand.transfer);
          const endpoint = row.indexOf(semaLogicCommand.transferEndpoint);
          let param = row.indexOf(semaLogicCommand.transferParam);
          const endCommand = row.lastIndexOf(semaLogicCommand.command_end);
          if (param < 0) {
            param = endCommand;
          }
          if (transfer <= 0) {
          } else {
            transferString = row.substring(transfer + semaLogicCommand.transfer.length + 1, endpoint);
            transferString = transferString.trimEnd();
            if (endpoint > 0) {
              endpointString = row.substring(endpoint + 1 + semaLogicCommand.transferEndpoint.length, param);
              endpointString = endpointString.trimEnd();
            }
            if (param > 0 && param != endCommand) {
              paramString = row.substring(param + 1 + semaLogicCommand.transferParam.length, endCommand);
              paramString = paramString.trimEnd();
            }
            let paramParsedCommand = {
              outputformat: transferString,
              endpoint: endpointString,
              param: paramString
            };
            if (parseInitial) {
              parseInitial = false;
              parseCommands.commands[0] = paramParsedCommand;
            } else {
              parseCommands.commands.push(paramParsedCommand);
            }
          }
        }
      });
    }
    return parseCommands;
  }
  async aspParse(slComm, settings, aspJsonParsedSemaLogic, RequestTime) {
    slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, "Start Transfer_Parse");
    let vAPI_URL = "";
    const parseCommands = this.getASPCommands(slComm, settings);
    parseCommands.commands.forEach((parseCommands2) => {
      if (parseCommands2.outputformat == RulesettypesCommands[Rstypes_ASP][1] || parseCommands2.outputformat == RulesettypesCommands[Rstypes_ASP][0]) {
        vAPI_URL = getHostAspPort(settings, parseCommands2);
      } else {
        vAPI_URL = parseCommands2.endpoint;
        if (parseCommands2.param != void 0) {
          if (parseCommands2.param.length > 0) {
            vAPI_URL = vAPI_URL + "?" + parseCommands2.param;
          }
        }
        slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, "Transfer URL: ", vAPI_URL);
      }
      let optionsParse = this.createRequest(this.slComm, settings, vAPI_URL, "POST", "json", true, aspJsonParsedSemaLogic);
      this.Resp(optionsParse, vAPI_URL, RequestTime);
    });
  }
  async Resp(optionsParse, vAPI_URL, RequestTime) {
    try {
      slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, "ASP: want to parse ", optionsParse);
      const responseParse = await (0, import_obsidian4.requestUrl)(optionsParse);
      const remJson = responseParse.text;
      slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, "ASP: Parse with http-status " + responseParse.status.toString());
      if (responseParse.status == 200) {
        if (this.slComm.slaspview.LastRequestTime == RequestTime) {
          let resulthttp = responseParse.text;
          this.setNewASPInitial(true);
          this.contentEl.createEl("br");
          this.contentEl.createEl("span", "---------------------------------------------------------");
          this.contentEl.createEl("br");
          resulthttp = resulthttp.replaceAll("[", "[\n");
          resulthttp = resulthttp.replaceAll("]", "\n]");
          resulthttp = resulthttp.replaceAll(",", ",\n");
          let resulthttpArray = resulthttp.split("\n");
          resulthttpArray.forEach((element) => {
            this.contentEl.append(element);
            this.contentEl.createEl("br");
          });
          slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, `ASP-Parseresult:${resulthttp}`);
        } else {
          slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, `Old_ASP-Request: ${RequestTime} vs ${this.slComm.slaspview.LastRequestTime}`);
        }
      }
    } catch (e) {
      slconsolelog(DebugLevMap.DebugLevel_Error, this.slComm.slview, `Catcherror of removing context ${vAPI_URL}`);
      slconsolelog(DebugLevMap.DebugLevel_Error, this.slComm.slview, e.toString());
      let text = new DocumentFragment();
      text.createEl("p");
      let textfragment = new Range().createContextualFragment(e.toString());
      text.appendChild(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment("See for information about the error-code of http: https://de.wikipedia.org/wiki/HTTP-Statuscode ");
      text.append(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment(optionsParse.url);
      text.append(textfragment);
      text.createEl("p");
      textfragment = new Range().createContextualFragment(String(optionsParse.body));
      text.append(textfragment);
      this.contentEl.empty();
      this.contentEl.createEl("br");
      this.contentEl.append(text);
    }
  }
};

// main.ts
var import_view3 = require("@codemirror/view");

// src/template.ts
var import_obsidian5 = require("obsidian");
async function createTemplateFolder(vault) {
  const templ = {
    folder: [
      {
        name: slTemplate["PathCommands"],
        files: [
          {
            name: "SL_Transfer",
            content: "SemaLogic(transfer %1 to endpoint %2 with param %3 )"
          },
          {
            name: "SL_ShowHelp",
            content: "SemaLogic(show help)"
          },
          {
            name: "SL_ShowVersion",
            content: "SemaLogic(show version)"
          },
          {
            name: "SL_TableDefine",
            content: "SemaLogic(define table)"
          },
          {
            name: "SL_Show",
            content: "SemaLogic(show as %1 for %2)"
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenComparison"],
        files: [
          {
            name: "SymTokenCompEqual",
            content: "=="
          },
          {
            name: "SymTokenCompGreater",
            content: ">"
          },
          {
            name: "SymTokenCompGreaterEqual",
            content: ">="
          },
          {
            name: "SymTokenCompLess",
            content: "<"
          },
          {
            name: "SymTokenCompLessEqual",
            content: "<="
          },
          {
            name: "SymTokenCompNotEqual",
            content: "!="
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenElements"],
        files: [
          {
            name: "SymTokenAnnounced",
            content: "%"
          },
          {
            name: "SymTokenAttribute",
            content: "$"
          },
          {
            name: "SymTokenCommentEnd",
            content: "*/"
          },
          {
            name: "SymTokenCommentStart",
            content: "/*"
          },
          {
            name: "SymTokenElement",
            content: ","
          },
          {
            name: "SymTokenEOL",
            content: "\n"
          },
          {
            name: "SymTokenEoS",
            content: ";"
          },
          {
            name: "SymTokenEqual",
            content: "\u2261"
          },
          {
            name: "SymTokenFilter",
            content: "\u25BC"
          },
          {
            name: "SymTokenGlobalMax",
            content: "+\u221E"
          },
          {
            name: "SymTokenGlobalMin",
            content: "-\u221E"
          },
          {
            name: "SymTokenIDDevider",
            content: "."
          },
          {
            name: "SymTokenInstance",
            content: "@"
          },
          {
            name: "SymTokenInterval",
            content: "|"
          },
          {
            name: "SymTokenLimit",
            content: "\u0141"
          },
          {
            name: "SymTokenLineComment",
            content: "//"
          },
          {
            name: "SymTokenReverseIDDevider",
            content: ":"
          },
          {
            name: "SymTokenSpace",
            content: " "
          },
          {
            name: "SymTokenVersion",
            content: "#"
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenFunc"],
        files: [
          {
            name: "FuncTokenCount",
            content: "Count"
          },
          {
            name: "FuncTokenMax",
            content: "Max"
          },
          {
            name: "FuncTokenMean",
            content: "Mean"
          },
          {
            name: "FuncTokenMin",
            content: "Min"
          },
          {
            name: "FuncTokenSum",
            content: "Sum"
          },
          {
            name: "FuncTokenUnDef",
            content: "_FuncUndef"
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenMath"],
        files: [
          {
            name: "SymTokenFunctionClose",
            content: ")"
          },
          {
            name: "SymTokenFunctionOpen",
            content: "("
          },
          {
            name: "SymTokenOpDivide",
            content: "/"
          },
          {
            name: "SymTokenOpMinus",
            content: "-"
          },
          {
            name: "SymTokenOpMultiply",
            content: "*"
          },
          {
            name: "SymTokenOpPlus",
            content: "+"
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenRefToken"],
        files: [
          {
            name: "RefTokenAll",
            content: "All"
          },
          {
            name: "RefTokenAnnounced",
            content: "Announced"
          },
          {
            name: "RefTokenChild",
            content: "Child"
          },
          {
            name: "RefTokenLeaf",
            content: "Leaf"
          },
          {
            name: "RefTokenRange",
            content: "Range"
          },
          {
            name: "RefTokenThis",
            content: "This"
          },
          {
            name: "RefTokenUnder",
            content: "Under"
          },
          {
            name: "RefTokenUsed",
            content: "Used"
          },
          {
            name: "RefTokenValue",
            content: "Value"
          }
        ]
      },
      {
        name: slTemplate["PathSymTokenTerms"],
        files: [
          {
            name: "SymTokenAdviceClose",
            content: "!"
          },
          {
            name: "SymTokenAdviceOpen",
            content: "\xA1"
          },
          {
            name: "SymTokenAndClose",
            content: "]"
          },
          {
            name: "SymTokenAndOpen",
            content: "["
          },
          {
            name: "SymTokenCheckClose",
            content: "?"
          },
          {
            name: "SymTokenCheckOpen",
            content: "\xBF"
          },
          {
            name: "SymTokenDialectDefine",
            content: "\u2261"
          },
          {
            name: "SymTokenEqual",
            content: ":="
          },
          {
            name: "SymTokenGroup",
            content: "~"
          },
          {
            name: "SymTokenOrClose",
            content: "}"
          },
          {
            name: "SymTokenOrOpen",
            content: "{"
          },
          {
            name: "SymTokenTimeAfter",
            content: "\u21FD"
          },
          {
            name: "SymTokenTimeBefore",
            content: "\u21FE"
          },
          {
            name: "SymTokenTimeParallelAfter",
            content: "\u2962"
          },
          {
            name: "SymTokenTimeParallelBefore",
            content: "\u2964"
          }
        ]
      }
    ]
  };
  for (var myfolder = 0; myfolder < templ.folder.length; myfolder++) {
    for (var myfile = 0; myfile < templ.folder[myfolder].files.length; myfile++) {
      vault.createFolder(templ.folder[myfolder].name).catch((error) => console.log(error));
      vault.create(
        (0, import_obsidian5.normalizePath)(templ.folder[myfolder].name + "/" + templ.folder[myfolder].files[myfile].name + ".md"),
        templ.folder[myfolder].files[myfile].content
      ).catch((error) => console.log(error));
    }
  }
}

// src/examples.ts
var import_obsidian6 = require("obsidian");
async function createExamples(vault) {
  const templ = {
    folder: [
      {
        name: slTemplate["PathExamplesBasic"],
        files: [
          {
            name: "00_Overview",
            content: "In the next exmaple files there are a few and simple examples to use SemaLogic for biulding semantic logical rulesets. In general the examples should show the operating principle opf SemaLogic and have in mind that the characters of the syntax of the technical language could be replaced by formal (more natural) language as it shown in example from 30 up. \n\n0x - 1x: Simple rules and some of the functionalties\n2x - 3x: Cascading rules and combining with functions\n4x - 5x: Formal language examples\n8x     : Additional technical information for values and so on\n 9x     : Little Glossar for SymTokens\n\n\nPlease keep in mind that this examples are work in progress and we try to expand them to show all the functionality of SemaLogic in future releases of this plugin. \n\nWe also working on [our website](www.SemaLogic.de) - which is currently only available in german -  and are writing an official document for all syntax and structures you are able to use in SemaLogic now and about planned funtionalities. But we can not do everything at the same time.\n\nTechnical Information for using SemaLogic in obsidian: With ALT + T you can access to the SemaLogicToken-Templates !"
          },
          {
            name: "01_AND-Rules",
            content: "Defining a simple and-rule in standard technical language : A is true - if B,C and D are true \n\n---\n\nA [B, C, D]\n"
          },
          {
            name: "02_OR-Rules",
            content: "Defining a simple or-rule in standard technical language : A is true - if B,C or D are true \n\n---\n\nA 1|1 {B, C, D}\n\nIn an OR-Rule it is possible to define how many of the symbols (B,C,D) must be true with the number before and after the pipe-symbol.\n\nE 1|2 {E,F,G}\n\nThis OR-Rule means that one or two of the three symbols (E,F,G) must be true, so that E ist true. If none of the symbols is true or all of them, E will be false as well.\nIf you don't use from|to in an or-rule then it is replaced by from one to all symbols - what means that a minimum of one of the symbols has to be true so that E is true. "
          },
          {
            name: "03_Groups",
            content: "If you don't want to reuse some symbols with in different rule, it it possible to define groups which will be inserted in rules instead of the groups name\n\n---\n\nMyGroup ~ Elem1, Elem2, Elem3 ~\nMyOptions 1|1 {MyGroup}\n"
          },
          {
            name: "04_Dynamic groups",
            content: "It is also possible to define groups for using them in rules, even if you do not know which symbols are in by using an interval.Then the members of the group are defined by the rules dynamically.\n\n---\n\nMyGroup ~ Elem1|Elem4 ~\nElem2 [A,B]\nELem4 {C,D}\nMyOptions 1|1 {MyGroup}\n\nIn this case the ruleset only knows the symbols Elem2 and Elem4, which are inherited by the interval from Elem1 till Elem4. So the group is replaced by Eleem2 and Elem4.\n"
          },
          {
            name: "05_Time dependencies",
            content: "It it possible to define time dependencies for the used symbols. So the results have to be 'time ordered'. \n\n---\n\nA \u21FE B;\nThis means that in a solution A must be sorted before B and in combination with time lines it means that A have to be fullfilled completely before B begins.\n\nA \u2964 B;\nThis means that in a solution A must be sorted before B and in combination with time lines it means that A have to be fullfilled completely before B ends.\n\nIf you want to define this time dependencies vice versa you could use for after \u21FD or for parallel after \u2962.\n"
          },
          {
            name: "10_Values",
            content: "There are a lot of possibilites to put values to the attributes of a symbol or the symbol itself.\n\n---\n\nA.attrib \u2261 15\n\nThis statement will put a value of 15 to the attribute attrib of the symbol A. For example you can define a symbol Germany and put a tax rate to this symbol like Germay.Sales Tax = 19\n"
          },
          {
            name: "15_Using Tables",
            content: "You can reading tables in many different variants to upload rules and relations \n\n---\n\n   SemaLogic(Define Ntable, header((module_exam_number_\u2026), [exam_number_\u2026]), order(1, 2))\n\n| module_exam_number | exam_number |\n| ------------------ | ----------- |\n| 1032 | 10321 |\n| 1030 | 10311 |\n| 1021 | 10213 |\n| 1021 | 10215 |\n| 1021 | 10216 |\n\n "
          },
          {
            name: "20_Cascading rules",
            content: "It is possible to cascade rule only by using same symbolname for a new rule : \nA is true - if B or C is true; \nB is true - if B1 or B2 is true\n C is true - if C1 and C2 are true \n\n---\n\nA [B, C]\nB {B1 , B2}\nC [C1 , C2]"
          },
          {
            name: "40_Formal Language",
            content: "It is possible replace technical Symtokens for using formal language,\nso it ispossible to change dialects as you want with words you use - offical dialects are under development  \n\n---\n\nDas Studium besteht aus einer Abschlussarbeit und umfasst Fachsemester 1 bis Fachsemester 4 als Elemente.\n\n\nSymTokenSpace\u2261einer \nSymTokenSpace\u2261Das \nSymTokenInterval\u2261bis \nSymTokenGroup\u2261 umfasst\nSymTokenGroup\u2261 als Elemente\nSymTokenAndOpen\u2261 besteht aus\nSymTokenElement\u2261 und\nSymTokenAndClose\u2261.\nSymTokenOrClose\u2261.\n"
          }
        ]
      }
    ]
  };
  for (var myfolder = 0; myfolder < templ.folder.length; myfolder++) {
    for (var myfile = 0; myfile < templ.folder[myfolder].files.length; myfile++) {
      vault.createFolder(templ.folder[myfolder].name).catch((error) => console.log(error));
      vault.create(
        (0, import_obsidian6.normalizePath)(templ.folder[myfolder].name + "/" + templ.folder[myfolder].files[myfile].name + ".md"),
        templ.folder[myfolder].files[myfile].content
      ).catch((error) => console.log(error));
    }
  }
}

// main.ts
var DebugLevel = 0;
var mygSID = String(Math.round(Math.random() * 99999999999));
var Default_profile = {
  mySLSettings: [
    {
      myPort: API_Defaults.Port,
      myOutputFormat: "SemaLogic",
      myBaseURL: API_Defaults.Base_URL,
      myGetAPI: API_Defaults.GetAPI,
      mySID: API_Defaults.SID,
      myContext: API_Defaults.ShowContext,
      myUseHttps: API_Defaults.useUserPasswortforHTTP,
      myUser: API_Defaults.HttpUser,
      myPassword: API_Defaults.HttpPassword,
      myUpdateInterval: Value_Defaults.updateInterval,
      myAspUrl: API_Defaults.AspUrl,
      myAspEndpoint: API_Defaults.AspEndpoint,
      myUseHttpsSL: API_Defaults.useUserPasswortforHTTPSL,
      myUserSL: API_Defaults.HttpUserSL,
      myPasswordSL: API_Defaults.HttpPasswordSL
    },
    {
      myPort: API_Defaults.Port,
      myOutputFormat: "SemaLogic",
      myBaseURL: API_Defaults.Base_URL,
      myGetAPI: API_Defaults.GetAPI,
      mySID: API_Defaults.SID,
      myContext: API_Defaults.ShowContext,
      myUseHttps: API_Defaults.useUserPasswortforHTTP,
      myUser: API_Defaults.HttpUser,
      myPassword: API_Defaults.HttpPassword,
      myUpdateInterval: Value_Defaults.updateInterval,
      myAspUrl: API_Defaults.AspUrl,
      myAspEndpoint: API_Defaults.AspEndpoint,
      myUseHttpsSL: API_Defaults.useUserPasswortforHTTPSL,
      myUserSL: API_Defaults.HttpUserSL,
      myPasswordSL: API_Defaults.HttpPasswordSL
    },
    {
      myPort: API_Defaults.Port,
      myOutputFormat: "SemaLogic",
      myBaseURL: API_Defaults.Base_URL,
      myGetAPI: API_Defaults.GetAPI,
      mySID: API_Defaults.SID,
      myContext: API_Defaults.ShowContext,
      myUseHttps: API_Defaults.useUserPasswortforHTTP,
      myUser: API_Defaults.HttpUser,
      myPassword: API_Defaults.HttpPassword,
      myUpdateInterval: Value_Defaults.updateInterval,
      myAspUrl: API_Defaults.AspUrl,
      myAspEndpoint: API_Defaults.AspEndpoint,
      myUseHttpsSL: API_Defaults.useUserPasswortforHTTPSL,
      myUserSL: API_Defaults.HttpUserSL,
      myPasswordSL: API_Defaults.HttpPasswordSL
    }
  ],
  mySetting: 0,
  myDebugLevel: 0
};
var SemaLogicSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for SemaLogic:" });
    new import_obsidian7.Setting(containerEl).setName("General DebugLevel").setDesc("You can set a DebugLevel for Developmentinformation").addDropdown((dropDown) => dropDown.addOption("0", DebugLevelNames[0]).addOption("1", DebugLevelNames[1]).addOption("2", DebugLevelNames[2]).addOption("3", DebugLevelNames[3]).addOption("4", DebugLevelNames[4]).addOption("5", DebugLevelNames[5]).setValue(String(this.plugin.settings.myDebugLevel)).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_High, void 0, "Set DebugLevel: " + DebugLevelNames[parseInt(value)]);
      this.plugin.settings.myDebugLevel = parseInt(value);
      DebugLevel = parseInt(value);
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian7.Setting(containerEl).setName("Change your setting profile").setDesc("You can define different profiles for your SemaLogicService").addDropdown((dropDown) => dropDown.addOption("0", "Profile 1").addOption("1", "Profile 2").addOption("2", "Profile 3").setValue(this.plugin.settings.mySetting.toString()).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_High, void 0, "Set Profile: " + value);
      this.plugin.settings.mySetting = parseInt(value);
      this.display();
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Standard updateinterval").addText((setting) => setting.setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUpdateInterval.toString()).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set Update Interval: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUpdateInterval = parseInt(value);
      window.clearInterval(this.plugin.interval);
      this.plugin.registerInterval(
        this.plugin.interval = window.setInterval(this.plugin.handleUpdate, this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUpdateInterval)
      );
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("BaseUrl").setDesc("BaseURL for reaching SemaLogicService").addText((text) => text.setPlaceholder(API_Defaults.Base_URL).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myBaseURL).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set BaseURL: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myBaseURL = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Path to Get-API-Endpoints").setDesc("Path to Get-API for more Information about the Endpoints of used APIs").addText((text) => text.setPlaceholder(API_Defaults.GetAPI).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myGetAPI).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set to Get-API-Endpoint: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myGetAPI = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Port SemaLogic").setDesc("Enter the Port").addText((text) => text.setPlaceholder(API_Defaults.Port).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPort).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set to Port: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPort = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("OutputFormat").setDesc("Here you can set the outputformat for SemaLogic, which could be get from SemaLogicService").addDropdown((dropDown) => dropDown.addOption(RulesettypesCommands[Rstypes_Semalogic][1], RulesettypesCommands[Rstypes_Semalogic][0]).addOption(RulesettypesCommands[Rstypes_ASP][1], RulesettypesCommands[Rstypes_ASP][0]).addOption(RulesettypesCommands[Rstypes_Picture][1], RulesettypesCommands[Rstypes_Picture][0]).addOption(RulesettypesCommands[Rstypes_SemanticTree][1], RulesettypesCommands[Rstypes_SemanticTree][0]).addOption(RulesettypesCommands[Rstypes_KnowledgeGraph][1], RulesettypesCommands[Rstypes_KnowledgeGraph][0]).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myOutputFormat).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set Outputformat: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myOutputFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Secure HTTP-Request SemaLogic").setDesc("If you has to use User/Password for http-request to the semalogic service").addToggle((setting) => setting.setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttpsSL).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set UserPasswordRequest: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttpsSL = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttpsSL) {
      new import_obsidian7.Setting(containerEl).setName("HTTP-Request-User").setDesc("User to reach transfer service").addText((text) => text.setPlaceholder(API_Defaults.HttpUserSL).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUserSL).onChange(async (value) => {
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set HTTP-Request-User...");
        this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUserSL = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian7.Setting(containerEl).setName("HTTP-Request-Password").setDesc("Password to reach transfer service").addText((text) => text.setPlaceholder(API_Defaults.HttpPasswordSL).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPasswordSL).onChange(async (value) => {
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set HTTP-Request-Password...");
        this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPasswordSL = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian7.Setting(containerEl).setName("Show Context in Reading View").addToggle((setting) => setting.setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myContext).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set Context of Reading View: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myContext = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h1", { text: "_______________________________" });
    containerEl.createEl("h2", { text: "Settings for Transfer/ASP-View:" });
    new import_obsidian7.Setting(containerEl).setName("BaseUrl for Transfer/ASP").setDesc("BaseURL for reaching Transfer/ASP-Service").addText((text) => text.setPlaceholder(API_Defaults.AspUrl).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myAspUrl).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set Transfer/ASP-BaseURL: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myAspUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Path to Get-Transfer/ASP-StandardAPI-Endpoint").setDesc("Path to Transfer/ASP-Standard-API ").addText((text) => text.setPlaceholder(API_Defaults.AspEndpoint).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myAspEndpoint).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set to Transfer/ASP-Standard-API-Endpoint: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myAspEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Secure HTTP-Request").setDesc("If you has to use User/Password for http-request to the transfer service").addToggle((setting) => setting.setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttps).onChange(async (value) => {
      slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set UserPasswordRequest: " + value);
      this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttps = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUseHttps) {
      new import_obsidian7.Setting(containerEl).setName("HTTP-Request-User").setDesc("User to reach transfer service").addText((text) => text.setPlaceholder(API_Defaults.HttpUser).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUser).onChange(async (value) => {
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set HTTP-Request-User...");
        this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myUser = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian7.Setting(containerEl).setName("HTTP-Request-Password").setDesc("Password to reach transfer service").addText((text) => text.setPlaceholder(API_Defaults.HttpPassword).setValue(this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPassword).onChange(async (value) => {
        slconsolelog(DebugLevMap.DebugLevel_Important, void 0, "Set HTTP-Request-Password...");
        this.plugin.settings.mySLSettings[this.plugin.settings.mySetting].myPassword = value;
        await this.plugin.saveSettings();
      }));
    }
  }
};
var SemaLogicPluginComm2 = class {
  constructor() {
    this.activatedASP = false;
    this.activatedKnowledge = false;
  }
  setSlView(view) {
    this.slview = view;
  }
  setSLClass(slclass) {
    this.slPlugin = slclass;
  }
  add(a, b) {
    return a + b;
  }
};
var SemaLogicPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.activated = false;
    this.updating = false;
    this.lastUpdate = 0;
    this.updateOutstanding = false;
    this.updateTransferOutstanding = false;
    this.updateOutstandingSetting = false;
    this.waitingForResponse = false;
    this.UpdateProcessing = false;
    this.view_utils = new ViewUtils();
    this.knowledgeCanvasPath = "SemaLogic/KnowledgeGraph.canvas";
    this.knowledgeLastRequestTime = 0;
    this.knowledgeEditCanvasPath = "SemaLogic/KnowledgeEdit.canvas";
    this.knowledgeEditLastCanvas = "";
    this.interpreterCanvasPath = "SemaLogic/SLInterpreter.canvas";
    this.interpreterLastCanvas = "";
    this.pauseAllRequests = false;
    this.handleUpdate = (update) => {
      if (this.pauseAllRequests) {
        return;
      }
      if (this.statusSL) {
        const text = "Updatetime/" + String(Date.now()) + "/" + String(this.lastUpdate) + "/" + String(Date.now() - this.lastUpdate) + "/" + String(this.updateOutstanding) + "/" + String(this.waitingForResponse);
        slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, text);
        if (update == null) {
        } else {
          if (update.view) {
            if (!update.docChanged && !update.focusChanged) {
              return;
            } else {
              if (this.UpdateProcessing == false) {
                slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, "Start Update docChanged, focuschanged, UpdProc  " + String(update.docChanged) + "/" + String(update.focusChanged) + "/" + String(this.UpdateProcessing));
                this.semaLogicUpdate();
              }
            }
          }
        }
        if (Date.now() - this.lastUpdate > this.settings.mySLSettings[this.settings.mySetting].myUpdateInterval && (this.updateOutstanding == true || this.updateTransferOutstanding == true) && this.waitingForResponse == false) {
          slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, "Start Update PARSING");
          this.lastUpdate = Date.now();
          this.semaLogicUpdate();
        } else if (Date.now() - this.lastUpdate > this.settings.mySLSettings[this.settings.mySetting].myUpdateInterval && this.updateOutstanding == true && this.waitingForResponse == false) {
          semaLogicPing(this.settings, this.lastUpdate);
        }
      }
    };
  }
  getContextFromLine(mydialectID) {
    mydialectID = mydialectID.replace("SemaLogicContext\u2261", "SemaLogicDialect\u2261");
    let re = /\t/gi;
    mydialectID = mydialectID.replace(re, "");
    re = /\n/gi;
    mydialectID = mydialectID.replace(re, "");
    return { mydialectID };
  }
  getActiveView() {
    const activeView = app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
    if (activeView === null) {
      if (this.lastactiveView === null) {
        slconsolelog(DebugLevMap.DebugLevel_High, this.slComm.slview, "ActiveView could not be defined through SemaLogic");
        return;
      } else {
        return this.lastactiveView;
      }
    }
    this.lastactiveView = activeView;
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, this.lastactiveView.getDisplayText());
    return this.lastactiveView;
  }
  setViews() {
    var _a;
    this.slComm.activatedASP = false;
    this.app.workspace.iterateAllLeaves((leaf) => {
      switch (leaf.view.getViewType()) {
        case SemaLogicViewType: {
          this.slComm.slview = leaf.view;
          this.slComm.slview.setComm(this.slComm);
          this.slComm.slview.slComm.setSlView(this.slComm.slview);
          this.slComm.slview.slComm.slPlugin = this.slComm.slPlugin;
          this.activated = true;
          this.statusSL = true;
          break;
        }
        case ASPViewType: {
          this.slComm.slaspview = leaf.view;
          this.slComm.slaspview.setComm(this.slComm);
          this.slComm.slaspview.slComm.setSlView(this.slComm.slview);
          this.slComm.slaspview.slComm.slPlugin = this.slComm.slPlugin;
          this.slComm.activatedASP = true;
          this.statusTransfer = true;
          break;
        }
      }
    });
    this.slComm.activatedKnowledge = this.knowledgeLeaf != void 0 || this.findKnowledgeCanvasLeaf() != void 0;
    slconsolelog(DebugLevMap.DebugLevel_Current_Dev, (_a = this.slComm) == null ? void 0 : _a.slview, "Knowledge active: " + String(this.slComm.activatedKnowledge));
    this.getActiveView();
  }
  async onload() {
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
      if (!this.activated) {
        return;
      }
      const selection = editor.getSelection();
      if (!selection || selection.length == 0) {
        return;
      }
      menu.addItem((item) => {
        item.setTitle("Edit in SL-Graph").onClick(() => {
          this.startKnowledgeEdit(view, selection);
        });
      });
      menu.addItem((item) => {
        item.setTitle("SL-Interpreter").onClick(() => {
          this.startSLInterpreter(view, selection);
        });
      });
    }));
    this.registerEvent(this.app.workspace.on("layout-change", () => {
      if (this.knowledgeEditLeaf != void 0 && this.findKnowledgeEditLeaf() == void 0) {
        this.stopKnowledgeEdit();
      }
      if (this.interpreterLeaf != void 0 && this.findInterpreterLeaf() == void 0) {
        this.stopSLInterpreter();
      }
    }));
    this.registerMarkdownPostProcessor((element, context) => {
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, element);
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, context);
      element.querySelectorAll("p").forEach((el) => {
        if (searchForSemaLogicCommands(el)) {
          let set = this.settings;
          context.addChild(new SemaLogicRenderedElement({ containerEl: el, set }));
        }
      });
    });
    this.addSettingTab(new SemaLogicSettingTab(this.app, this));
    await this.loadSettings();
    DebugLevel = this.settings.myDebugLevel;
    this.myStatus = this.addStatusBarItem();
    this.slComm = new SemaLogicPluginComm2();
    this.slComm.setSLClass(this);
    this.activateView();
    await this.semaLogicReset();
    this.setViews();
    this.addRibbonIcon("book", "On/Off SemaLogic.View", () => {
      this.setViews();
      if (this.activated == false) {
        this.statusSL = true;
        if (!this.activated) {
          this.activateView();
        }
      } else {
        this.statusSL = false;
        this.deactivateView();
      }
    });
    this.addRibbonIcon("dice", "On/Off Transfer.View", () => {
      this.setViews();
      if (this.slComm != void 0) {
        if (this.slComm.activatedASP == false) {
          this.activateASPView();
        } else {
          this.deactivateASPView();
        }
      }
    });
    this.addRibbonIcon("share-2", "On/Off Knowledge.View", () => {
      this.setViews();
      if (this.slComm != void 0) {
        if (this.slComm.activatedKnowledge == false) {
          this.activateKnowledgeView();
        } else {
          this.deactivateKnowledgeView();
        }
      }
    });
    this.addCommand({
      id: "sl_create_template",
      name: "SemaLogic create template",
      callback: () => {
        createTemplateFolder(app.vault);
        createExamples(app.vault);
      }
    });
    if (this.statusSL) {
      this.semaLogicReset();
      this.slComm.slview.setNewInitial(this.settings.mySLSettings[this.settings.mySetting].myOutputFormat, true);
      this.semaLogicParse();
    }
    this.registerInterval(
      this.interval = window.setInterval(this.handleUpdate, this.settings.mySLSettings[this.settings.mySetting].myUpdateInterval)
    );
    this.registerEditorExtension([import_view3.EditorView.updateListener.of(this.handleUpdate)]);
  }
  async semaLogicParse() {
    if (this.pauseAllRequests) {
      return [];
    }
    this.setViews();
    slconsolelog(DebugLevMap.DebugLevel_, this.slComm.slview, "Start SemaLogicParse");
    let results = [];
    this.lastUpdate = Date.now();
    await semaLogicPing(this.settings, this.lastUpdate);
    let vAPI_URL = getHostPort(this.settings) + API_Defaults.rules_parse + "?sid=" + mygSID;
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, vAPI_URL);
    let bodytext = "";
    let activeView = this.getActiveView();
    if (activeView != void 0) {
      this.slComm.slUsedMDView = activeView;
    }
    let dialectID = "default";
    let codeblock = false;
    let newCodeblock = false;
    if (activeView != null) {
      slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, "ActiveView is not NULL");
      for (let i = 0; i < activeView.editor.lineCount(); i++) {
        slconsolelog(DebugLevMap.DebugLevel_All, this.slComm.slview, i, ";", activeView.editor.getLine(i));
        slconsolelog(DebugLevMap.DebugLevel_All, this.slComm.slview, "Substring:", activeView.editor.getLine(i).substring(0, 2));
        if (activeView.editor.getLine(i).substring(0, 3) == "```") {
          if (!codeblock) {
            codeblock = true;
            newCodeblock = true;
            slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, "Current line is Codeblock: " + i.toString(), codeblock);
          } else {
            newCodeblock = false;
          }
        }
        if (!codeblock && !newCodeblock) {
          bodytext = bodytext.concat(activeView.editor.getLine(i) + "\n");
        } else {
          switch (activeView.editor.getLine(i).substring(0, semaLogicCommand.useDialect.length)) {
            case semaLogicCommand.useDialect: {
              dialectID = activeView.editor.getLine(i).substring(semaLogicCommand.useDialect.length, activeView.editor.getLine(i).length - 1);
              dialectID = dialectID.trim();
              break;
            }
            default: {
            }
          }
        }
        if (i < activeView.editor.lineCount()) {
          if (activeView.editor.getLine(i).substring(0, 3) == "```") {
            if (codeblock && !newCodeblock) {
              codeblock = false;
            } else {
              newCodeblock = false;
            }
          }
        }
      }
    }
    bodytext = this.view_utils.cleanCommands(bodytext);
    if (dialectID == "") {
      dialectID = "default";
    }
    slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "Parsingresult for SemaLogicView");
    const responseForSemaLogic = this.slComm.slview.getSemaLogicParse(this.settings, vAPI_URL, dialectID, bodytext, false);
    responseForSemaLogic.then((value) => {
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, value);
    });
    if (this.slComm.activatedASP) {
      if (Date.now() - this.slComm.slaspview.LastRequestTime >= this.settings.mySLSettings[this.settings.mySetting].myUpdateInterval) {
        this.slComm.slaspview.LastRequestTime = Date.now();
        slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, `Set-Requesttime: ${this.slComm.slaspview.LastRequestTime}`);
        this.updateTransferOutstanding = false;
        let outputFormat = RulesettypesCommands[Rstypes_ASP][1];
        const responseForASP = this.slComm.slview.getSemaLogicParse(this.settings, vAPI_URL, dialectID, bodytext, true, outputFormat);
        responseForASP.then((value) => {
          slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, value);
          const aspPromise = this.slComm.slaspview.aspParse(this.slComm, this.settings, value, this.slComm.slaspview.LastRequestTime);
          aspPromise.then((value2) => {
            if (value2 != void 0) {
              slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, value2);
            }
          });
        });
      } else {
        this.updateTransferOutstanding = true;
      }
    }
    if (this.slComm.activatedKnowledge) {
      if (Date.now() - this.knowledgeLastRequestTime >= this.settings.mySLSettings[this.settings.mySetting].myUpdateInterval) {
        this.knowledgeLastRequestTime = Date.now();
        const requestTime = this.knowledgeLastRequestTime;
        slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, `Knowledge request (sid=${mygSID}) url=${vAPI_URL}`);
        const responseForKnowledge = this.slComm.slview.getSemaLogicParse(this.settings, vAPI_URL, dialectID, bodytext, true, RulesettypesCommands[Rstypes_KnowledgeGraph][1]);
        responseForKnowledge.then((value) => {
          if (this.knowledgeLastRequestTime == requestTime) {
            this.updateKnowledgeCanvas(value);
          }
        });
      }
    }
    return results;
  }
  async activateASPView() {
    if (this.slComm.slaspview == void 0) {
      this.registerView(
        ASPViewType,
        (leaf2) => new ASPView(leaf2)
      );
    }
    const leaf = this.GetAspLeaf();
    if (leaf != void 0) {
      leaf.setViewState({
        type: ASPViewType,
        active: false
      });
      await this.semaLogicReset();
      this.app.workspace.revealLeaf(leaf);
    } else {
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "ASP-Leaf not created");
    }
    this.setViews();
    this.handlePing();
    this.statusTransfer = true;
    this.semaLogicUpdate();
    this.myStatus.setText("ASP is on");
  }
  async activateKnowledgeView() {
    var _a;
    slconsolelog(DebugLevMap.DebugLevel_Current_Dev, (_a = this.slComm) == null ? void 0 : _a.slview, "Activate KnowledgeView");
    await this.openKnowledgeCanvas();
    this.setViews();
    this.handlePing();
    this.semaLogicUpdate();
    this.myStatus.setText("Knowledge is on");
  }
  async activateView() {
    if (this.slComm.slview == void 0) {
      this.registerView(
        SemaLogicViewType,
        (leaf2) => new SemaLogicView2(leaf2)
      );
    }
    const leaf = this.GetSemaLogicLeaf();
    if (leaf != void 0) {
      leaf.setViewState({
        type: SemaLogicViewType,
        active: false
      });
      await this.semaLogicReset();
      this.app.workspace.revealLeaf(leaf);
    } else {
      slconsolelog(DebugLevMap.DebugLevel_Chatty, void 0, "SemaLogic-Leaf not created");
    }
    this.setViews();
    this.handlePing();
    this.semaLogicUpdate();
    this.myStatus.setText("SemaLogic is on");
  }
  async deactivateASPView() {
    this.app.workspace.detachLeavesOfType(ASPViewType);
    this.slComm.activatedASP = false;
    this.statusTransfer = true;
    this.myStatus.setText("ASP is off");
  }
  async deactivateKnowledgeView() {
    this.detachKnowledgeCanvasLeaves();
    this.slComm.activatedKnowledge = false;
    this.myStatus.setText("Knowledge is off");
  }
  async deactivateView() {
    this.app.workspace.detachLeavesOfType(SemaLogicViewType);
    this.activated = false;
    this.slComm.slview.unload();
    this.myStatus.setText("SemaLogic is off");
  }
  GetAspLeaf() {
    let found = false;
    let slv = void 0;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (!found) {
        switch (leaf.view.getViewType()) {
          case ASPViewType: {
            found = true;
            slv = leaf;
          }
        }
      }
    });
    if (!found) {
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, "Split");
      slv = this.app.workspace.getLeaf("split");
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, slv);
    }
    return slv;
  }
  GetSemaLogicLeaf() {
    let found = false;
    let slv = void 0;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (!found) {
        switch (leaf.view.getViewType()) {
          case SemaLogicViewType: {
            found = true;
            slv = leaf;
          }
        }
      }
    });
    if (!found) {
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, "Split");
      slv = this.app.workspace.getLeaf("split");
      slconsolelog(DebugLevMap.DebugLevel_All, void 0, slv);
    }
    return slv;
  }
  async ensureKnowledgeCanvasFile(content) {
    const path = (0, import_obsidian7.normalizePath)(this.knowledgeCanvasPath);
    const folder = path.split("/").slice(0, -1).join("/");
    if (folder.length > 0 && this.app.vault.getAbstractFileByPath(folder) == null) {
      await this.app.vault.createFolder(folder);
    }
    let file = this.app.vault.getAbstractFileByPath(path);
    if (file == null) {
      file = await this.app.vault.create(path, content != null ? content : '{ "nodes": [], "edges": [] }');
    } else if (content != void 0) {
      await this.app.vault.adapter.write(path, content);
      await this.app.vault.modify(file, content);
    }
    return file;
  }
  findKnowledgeCanvasLeaf() {
    let found = void 0;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (found != void 0) {
        return;
      }
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian7.normalizePath)(file.path) == (0, import_obsidian7.normalizePath)(this.knowledgeCanvasPath)) {
          found = leaf;
        }
      }
    });
    if (found != void 0) {
      this.knowledgeLeaf = found;
    }
    return found;
  }
  detachKnowledgeCanvasLeaves() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian7.normalizePath)(file.path) == (0, import_obsidian7.normalizePath)(this.knowledgeCanvasPath)) {
          leaf.detach();
        }
      }
    });
    this.knowledgeLeaf = void 0;
  }
  async openKnowledgeCanvas() {
    const file = await this.ensureKnowledgeCanvasFile();
    let leaf = this.findKnowledgeCanvasLeaf();
    if (leaf == void 0) {
      leaf = this.app.workspace.getLeaf("split");
    }
    this.knowledgeLeaf = leaf;
    await leaf.openFile(file, { active: false });
    this.slComm.activatedKnowledge = true;
  }
  async updateKnowledgeCanvas(content) {
    var _a;
    slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, `Update KnowledgeCanvas (len=${(_a = content == null ? void 0 : content.length) != null ? _a : 0})`);
    const file = await this.ensureKnowledgeCanvasFile(content);
    let leaf = this.knowledgeLeaf;
    if (leaf == void 0) {
      leaf = this.findKnowledgeCanvasLeaf();
    }
    if (leaf != void 0) {
      this.knowledgeLeaf = leaf;
      await leaf.openFile(file, { active: false });
    }
  }
  async ensureKnowledgeEditCanvasFile(content) {
    const path = (0, import_obsidian7.normalizePath)(this.knowledgeEditCanvasPath);
    const folder = path.split("/").slice(0, -1).join("/");
    if (folder.length > 0 && this.app.vault.getAbstractFileByPath(folder) == null) {
      await this.app.vault.createFolder(folder);
    }
    let file = this.app.vault.getAbstractFileByPath(path);
    if (file == null) {
      file = await this.app.vault.create(path, content != null ? content : '{ "nodes": [], "edges": [] }');
    } else if (content != void 0) {
      await this.app.vault.adapter.write(path, content);
      await this.app.vault.modify(file, content);
    }
    return file;
  }
  findKnowledgeEditLeaf() {
    let found = void 0;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (found != void 0) {
        return;
      }
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian7.normalizePath)(file.path) == (0, import_obsidian7.normalizePath)(this.knowledgeEditCanvasPath)) {
          found = leaf;
        }
      }
    });
    if (found != void 0) {
      this.knowledgeEditLeaf = found;
    }
    return found;
  }
  detachKnowledgeEditCanvasLeaves() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian7.normalizePath)(file.path) == (0, import_obsidian7.normalizePath)(this.knowledgeEditCanvasPath)) {
          leaf.detach();
        }
      }
    });
    this.knowledgeEditLeaf = void 0;
  }
  async openKnowledgeEditCanvas() {
    const file = await this.ensureKnowledgeEditCanvasFile();
    let leaf = this.findKnowledgeEditLeaf();
    if (leaf == void 0) {
      leaf = this.app.workspace.getLeaf("split");
    }
    this.knowledgeEditLeaf = leaf;
    await leaf.openFile(file, { active: false });
  }
  async tickKnowledgeEdit() {
    var _a, _b, _c;
    if (!this.pauseAllRequests || this.knowledgeEditSelection == void 0) {
      return;
    }
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_a = this.slComm) == null ? void 0 : _a.slview, "KnowledgeEdit tick");
    const file = await this.ensureKnowledgeEditCanvasFile();
    const content = await this.app.vault.adapter.read(file.path);
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_b = this.slComm) == null ? void 0 : _b.slview, `KnowledgeEdit canvas len=${content.length}`);
    if (content == this.knowledgeEditLastCanvas) {
      return;
    }
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_c = this.slComm) == null ? void 0 : _c.slview, "KnowledgeEdit canvas changed");
    this.knowledgeEditLastCanvas = content;
    const vAPI_URL = getHostPort(this.settings) + "/canvas/convert";
    const response = await this.requestCanvasConvert(vAPI_URL, content);
    if (response == void 0 || response.length == 0) {
      return;
    }
    const sel = this.knowledgeEditSelection;
    const editor = sel.view.editor;
    const current = editor.getRange(sel.from, sel.to);
    if (current != sel.original) {
      slconsolelog(DebugLevMap.DebugLevel_Current_Dev, this.slComm.slview, "KnowledgeEdit: selection changed, skip replace");
      return;
    }
    editor.replaceRange(response, sel.from, sel.to);
    const fromOffset = editor.posToOffset(sel.from);
    sel.to = editor.offsetToPos(fromOffset + response.length);
    sel.original = response;
    this.pauseAllRequests = false;
    this.semaLogicUpdate();
    this.pauseAllRequests = true;
  }
  async startKnowledgeEdit(view, selection) {
    var _a;
    if (!this.activated || selection.length == 0) {
      return;
    }
    slconsolelog(DebugLevMap.DebugLevel_Informative, (_a = this.slComm) == null ? void 0 : _a.slview, "Start KnowledgeEdit");
    this.pauseAllRequests = true;
    this.updateOutstanding = false;
    this.updateTransferOutstanding = false;
    this.knowledgeEditLastCanvas = "";
    const from = view.editor.getCursor("from");
    const to = view.editor.getCursor("to");
    this.knowledgeEditSelection = { view, from, to, original: selection };
    const vAPI_URL = getHostPort(this.settings) + API_Defaults.rules_parse + "?sid=" + mygSID;
    const response = await this.slComm.slview.getSemaLogicParse(this.settings, vAPI_URL, "default", selection, true, RulesettypesCommands[Rstypes_KnowledgeGraph][1]);
    await this.ensureKnowledgeEditCanvasFile(response);
    await this.openKnowledgeEditCanvas();
    if (this.knowledgeEditInterval != void 0) {
      window.clearInterval(this.knowledgeEditInterval);
    }
    this.knowledgeEditInterval = window.setInterval(() => {
      this.tickKnowledgeEdit();
    }, 1e3);
  }
  async stopKnowledgeEdit() {
    if (this.knowledgeEditInterval != void 0) {
      window.clearInterval(this.knowledgeEditInterval);
      this.knowledgeEditInterval = void 0;
    }
    this.detachKnowledgeEditCanvasLeaves();
    const file = this.app.vault.getAbstractFileByPath((0, import_obsidian7.normalizePath)(this.knowledgeEditCanvasPath));
    if (file != void 0) {
      await this.app.vault.delete(file);
    }
    this.knowledgeEditLastCanvas = "";
    this.knowledgeEditSelection = void 0;
    this.pauseAllRequests = false;
  }
  async ensureInterpreterCanvasFile(content) {
    const path = (0, import_obsidian7.normalizePath)(this.interpreterCanvasPath);
    const folder = path.split("/").slice(0, -1).join("/");
    if (folder.length > 0 && this.app.vault.getAbstractFileByPath(folder) == null) {
      await this.app.vault.createFolder(folder);
    }
    let file = this.app.vault.getAbstractFileByPath(path);
    if (file == null) {
      file = await this.app.vault.create(path, content != null ? content : '{ "nodes": [], "edges": [] }');
    } else if (content != void 0) {
      await this.app.vault.adapter.write(path, content);
      await this.app.vault.modify(file, content);
    }
    return file;
  }
  findInterpreterLeaf() {
    let found = void 0;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (found != void 0) {
        return;
      }
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian7.normalizePath)(file.path) == (0, import_obsidian7.normalizePath)(this.interpreterCanvasPath)) {
          found = leaf;
        }
      }
    });
    if (found != void 0) {
      this.interpreterLeaf = found;
    }
    return found;
  }
  detachInterpreterCanvasLeaves() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() == "canvas") {
        const file = leaf.view.file;
        if (file != void 0 && (0, import_obsidian7.normalizePath)(file.path) == (0, import_obsidian7.normalizePath)(this.interpreterCanvasPath)) {
          leaf.detach();
        }
      }
    });
    this.interpreterLeaf = void 0;
  }
  async openInterpreterCanvas() {
    const file = await this.ensureInterpreterCanvasFile();
    let leaf = this.findInterpreterLeaf();
    if (leaf == void 0) {
      leaf = this.app.workspace.getLeaf("split");
    }
    this.interpreterLeaf = leaf;
    await leaf.openFile(file, { active: false });
  }
  async tickSLInterpreter() {
    var _a;
    if (!this.pauseAllRequests || this.interpreterSelection == void 0) {
      return;
    }
    const file = await this.ensureInterpreterCanvasFile();
    const content = await this.app.vault.adapter.read(file.path);
    if (content == this.interpreterLastCanvas) {
      return;
    }
    this.interpreterLastCanvas = content;
    const vAPI_URL = getHostPort(this.settings) + "/canvas/convert";
    const response = await this.requestCanvasConvert(vAPI_URL, content);
    if (response == void 0 || response.length == 0) {
      return;
    }
    const sel = this.interpreterSelection;
    const editor = sel.view.editor;
    const current = editor.getRange(sel.from, sel.to);
    if (current != sel.lastRendered && current != sel.original) {
      slconsolelog(DebugLevMap.DebugLevel_Informative, (_a = this.slComm) == null ? void 0 : _a.slview, "SL-Interpreter: selection changed, skip replace");
      return;
    }
    const newText = `[${sel.original}] (<span class="sl-term">${response}</span>)`;
    editor.replaceRange(newText, sel.from, sel.to);
    const fromOffset = editor.posToOffset(sel.from);
    sel.to = editor.offsetToPos(fromOffset + newText.length);
    sel.lastRendered = newText;
    this.pauseAllRequests = false;
    this.semaLogicUpdate();
    this.pauseAllRequests = true;
  }
  async startSLInterpreter(view, selection) {
    if (!this.activated || selection.length == 0) {
      return;
    }
    this.pauseAllRequests = true;
    this.updateOutstanding = false;
    this.updateTransferOutstanding = false;
    this.interpreterLastCanvas = "";
    const from = view.editor.getCursor("from");
    const to = view.editor.getCursor("to");
    this.interpreterSelection = { view, from, to, original: selection, lastRendered: selection };
    const vAPI_URL = getHostPort(this.settings) + API_Defaults.rules_parse + "?sid=" + mygSID;
    const response = await this.slComm.slview.getSemaLogicParse(this.settings, vAPI_URL, "default", selection, true, RulesettypesCommands[Rstypes_KnowledgeGraph][1]);
    if (response.length > 0) {
      await this.ensureInterpreterCanvasFile(response);
    } else {
      await this.ensureInterpreterCanvasFile();
    }
    await this.openInterpreterCanvas();
    if (this.interpreterInterval != void 0) {
      window.clearInterval(this.interpreterInterval);
    }
    this.interpreterInterval = window.setInterval(() => {
      this.tickSLInterpreter();
    }, 1e3);
  }
  async stopSLInterpreter() {
    if (this.interpreterInterval != void 0) {
      window.clearInterval(this.interpreterInterval);
      this.interpreterInterval = void 0;
    }
    this.detachInterpreterCanvasLeaves();
    const file = this.app.vault.getAbstractFileByPath((0, import_obsidian7.normalizePath)(this.interpreterCanvasPath));
    if (file != void 0) {
      await this.app.vault.delete(file);
    }
    this.interpreterLastCanvas = "";
    this.interpreterSelection = void 0;
    this.pauseAllRequests = false;
  }
  async requestCanvasConvert(apiUrl, canvasJson) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    let body = "";
    try {
      let parsed;
      try {
        parsed = JSON.parse(canvasJson);
      } catch (e) {
        slconsolelog(DebugLevMap.DebugLevel_Error, (_a = this.slComm) == null ? void 0 : _a.slview, `Canvas2SL invalid JSON: ${e}`);
        return "";
      }
      const bodyObj = {
        nodes: Array.isArray(parsed == null ? void 0 : parsed.nodes) ? parsed.nodes : [],
        edges: Array.isArray(parsed == null ? void 0 : parsed.edges) ? parsed.edges : []
      };
      body = JSON.stringify(bodyObj);
      slconsolelog(DebugLevMap.DebugLevel_Informative, (_b = this.slComm) == null ? void 0 : _b.slview, `Canvas2SL request len=${body.length} nodes=${bodyObj.nodes.length} edges=${bodyObj.edges.length}`);
      const response = await (0, import_obsidian7.requestUrl)({
        url: apiUrl,
        method: "POST",
        headers: {
          "content-type": "application/json",
          "accept": "text/plain, application/json"
        },
        body
      });
      if (response.status == 200) {
        const text = (_c = response.text) != null ? _c : "";
        slconsolelog(DebugLevMap.DebugLevel_Informative, (_d = this.slComm) == null ? void 0 : _d.slview, `Canvas2SL ok len=${text.length}`);
        if (text.trim().length > 0) {
          return text;
        }
        const jsonValue = response.json;
        if (jsonValue != void 0) {
          slconsolelog(DebugLevMap.DebugLevel_Informative, (_e = this.slComm) == null ? void 0 : _e.slview, `Canvas2SL json type=${typeof jsonValue}`);
          if (typeof jsonValue === "string") {
            return jsonValue;
          }
          return JSON.stringify(jsonValue);
        }
        return "";
      }
      slconsolelog(DebugLevMap.DebugLevel_Error, (_f = this.slComm) == null ? void 0 : _f.slview, `Canvas2SL status ${response.status}`);
      slconsolelog(DebugLevMap.DebugLevel_Error, (_g = this.slComm) == null ? void 0 : _g.slview, { url: apiUrl, headers: { "content-type": "application/json", "accept": "text/plain, application/json" }, body });
    } catch (e) {
      const err = e;
      const status = (_i = err == null ? void 0 : err.status) != null ? _i : (_h = err == null ? void 0 : err.response) == null ? void 0 : _h.status;
      const respText = (_l = (_k = (_j = err == null ? void 0 : err.response) == null ? void 0 : _j.text) != null ? _k : err == null ? void 0 : err.text) != null ? _l : "";
      slconsolelog(DebugLevMap.DebugLevel_Error, (_m = this.slComm) == null ? void 0 : _m.slview, `Canvas2SL failed: status=${status} text=${respText}`);
      slconsolelog(DebugLevMap.DebugLevel_Error, (_n = this.slComm) == null ? void 0 : _n.slview, { url: apiUrl, headers: { "content-type": "application/json", "accept": "text/plain, application/json" }, body });
    }
    return "";
  }
  async onunload() {
    this.app.workspace.detachLeavesOfType(SemaLogicViewType);
    this.app.workspace.detachLeavesOfType(ASPViewType);
    this.detachKnowledgeCanvasLeaves();
    this.detachKnowledgeEditCanvasLeaves();
    this.detachInterpreterCanvasLeaves();
    await this.stopKnowledgeEdit();
    await this.stopSLInterpreter();
  }
  async loadSettings() {
    this.settings = Object.assign({}, Default_profile, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.slComm.slview != void 0) {
      this.slComm.slview.setNewInitial(this.settings.mySLSettings[this.settings.mySetting].myOutputFormat, false);
    }
    this.updateOutstanding = true;
  }
  handlePing() {
    semaLogicPing(this.settings, this.lastUpdate);
  }
  semaLogicUpdate(setView) {
    this.waitingForResponse = true;
    this.UpdateProcessing = true;
    if (setView == true || setView == void 0) {
      this.setViews();
    }
    slconsolelog(DebugLevMap.DebugLevel_Chatty, this.slComm.slview, "Start SemaLogicUpdate");
    this.setViews();
    let activeView = this.getActiveView();
    this.semaLogicParse();
    if (!this.updating) {
      this.updating = true;
      this.updating = false;
    }
    this.UpdateProcessing = false;
    this.waitingForResponse = false;
  }
  getSemaLogicText() {
    if (this.slComm.slview.contentEl.textContent == null) {
      return "";
    } else {
      return this.slComm.slview.getContent();
    }
  }
  async semaLogicReset() {
    let vAPI_URL_Reset = getHostPort(this.settings) + API_Defaults.reset + "?sid=" + mygSID;
    let optionsReset;
    if (this.settings.mySLSettings[this.settings.mySetting].myUseHttpsSL && this.settings.mySLSettings[this.settings.mySetting].myUserSL != "") {
      optionsReset = {
        url: vAPI_URL_Reset,
        method: "POST",
        headers: {
          "content-type": "text/plain",
          "Authorization": "Basic " + btoa(this.settings.mySLSettings[this.settings.mySetting].myUserSL + ":" + this.settings.mySLSettings[this.settings.mySetting].myPasswordSL)
        }
      };
    } else {
      optionsReset = {
        url: vAPI_URL_Reset,
        method: "POST",
        headers: {
          "content-type": "text/plain"
        }
      };
    }
    slconsolelog(DebugLevMap.DebugLevel_Important, this.slComm.slview, optionsReset);
    try {
      const responseReset = await (0, import_obsidian7.requestUrl)(optionsReset);
      slconsolelog(DebugLevMap.DebugLevel_Informative, this.slComm.slview, `SemaLogic: Reset with http-status ${responseReset.status.toString()}`);
    } catch (e) {
      slconsolelog(DebugLevMap.DebugLevel_Error, this.slComm.slview, `Catcherror by reset ${vAPI_URL_Reset}`);
      slconsolelog(DebugLevMap.DebugLevel_Error, this.slComm.slview, e.toString());
    }
  }
};
